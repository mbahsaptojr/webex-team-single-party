/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-conversation';
import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import {browserOnly, handleErrorEvent} from '@ciscospark/test-helper-mocha';
import {base64} from '@ciscospark/common';

import {
  expectActiveEvent,
  expectCallIncomingEvent
} from '../lib/event-expectations';

browserOnly(describe)('plugin-phone', function () {
  this.timeout(30000);

  describe('Call', () => {
    describe('with group calling enabled', () => {
      let mccoy, spock, bones, participants;
      beforeEach('create users and register', () => testUsers.create({count: 3})
        .then((users) => {
          [mccoy, spock, bones] = users;
          participants = [mccoy, spock, bones];
          spock.spark = new CiscoSpark({
            credentials: {
              authorization: spock.token
            },
            config: {
              phone: {
                enableExperimentalGroupCallingSupport: true
              }
            }
          });

          mccoy.spark = new CiscoSpark({
            credentials: {
              authorization: mccoy.token
            },
            config: {
              phone: {
                enableExperimentalGroupCallingSupport: true
              }
            }
          });

          return Promise.all([
            spock.spark.phone.register(),
            mccoy.spark.phone.register()
          ]);
        }));

      afterEach('unregister spock and mccoy', () => Promise.all([
        spock && spock.spark.phone.deregister()
          // eslint-disable-next-line no-console
          .catch((reason) => console.warn('could not disconnect spock from mercury', reason)),
        mccoy && mccoy.spark.phone.deregister()
          // eslint-disable-next-line no-console
          .catch((reason) => console.warn('could not disconnect mccoy from mercury', reason))
      ]));

      describe('#from', () => {
        describe('1:1 spaces', () => {
          it('represents the initiating party on a 1:1', () => handleErrorEvent(spock.spark.phone.dial(mccoy.email), (call) => Promise.all([
            expectCallIncomingEvent(mccoy.spark.phone)
              .then((c) => c.answer()),
            expectActiveEvent(call)
              .then(() => {
                assert.property(call.from, 'isInitiator');
                assert.property(call.from, 'personId');
                assert.property(call.from, 'state');
                assert.isHydraID(call.from.personId);
                assert.isTrue(call.from.isInitiator);
                assert.equal(base64.decode(call.from.personId).split('/').pop(), spock.id);
              })
          ])));
        });

        describe('space calling', () => {
          let conversationUrl;
          beforeEach('create group space', () => spock.spark.internal.conversation.create({participants}).then((c) => {
            conversationUrl = base64.encode(`ciscospark://us/ROOM/${c.id}`);
          }));

          it('is undefined for a group call', () => handleErrorEvent(spock.spark.phone.dial(conversationUrl), (call) => Promise.all([
            expectCallIncomingEvent(mccoy.spark.phone)
              .then((c) => {
                mccoy.spark.logger.info(c);
                c.answer();
              }),
            expectActiveEvent(call)
              .then(() => {
                assert.isUndefined(call.from);
              })
          ])));
        });
      });

      describe('#host', () => {
        describe('1:1 spaces', () => {
          it('represents the initiating party on a 1:1', () => handleErrorEvent(spock.spark.phone.dial(mccoy.email), (call) => Promise.all([
            expectCallIncomingEvent(mccoy.spark.phone)
              .then((c) => c.answer()),
            expectActiveEvent(call)
              .then(() => {
                assert.property(call.host, 'id');
                assert.property(call.host, 'name');
                assert.equal(call.host.id, spock.id);
              })
          ])));
        });

        describe('space calling', () => {
          let conversationUrl;
          beforeEach('create group space', () => spock.spark.internal.conversation.create({participants}).then((c) => {
            conversationUrl = base64.encode(`ciscospark://us/ROOM/${c.id}`);
          }));

          it('is initiator of the group call', () => handleErrorEvent(spock.spark.phone.dial(conversationUrl), (call) => Promise.all([
            expectCallIncomingEvent(mccoy.spark.phone)
              .then((c) => {
                c.answer();
              }),
            expectActiveEvent(call)
              .then(() => {
                assert.property(call.host, 'id');
                assert.property(call.host, 'name');
                assert.equal(call.host.id, spock.id);
              })
          ])));
        });
      });

      describe('#roomId', () => {
        describe('1:1 spaces', () => {
          it('represents the initiating party on a 1:1', () => handleErrorEvent(spock.spark.phone.dial(mccoy.email), (call) => Promise.all([
            expectCallIncomingEvent(mccoy.spark.phone)
              .then((c) => c.answer()),
            expectActiveEvent(call)
              .then(() => {
                assert.property(call, 'roomId');
                assert.isHydraID(call.roomId);
              })
          ])));
        });

        describe('space calling', () => {
          let conversationUrl;
          beforeEach('create group space', () => spock.spark.internal.conversation.create({participants}).then((c) => {
            conversationUrl = base64.encode(`ciscospark://us/ROOM/${c.id}`);
          }));

          it('is initiator of the group call', () => handleErrorEvent(spock.spark.phone.dial(conversationUrl), (call) => Promise.all([
            expectCallIncomingEvent(mccoy.spark.phone)
              .then((c) => {
                c.answer();
              }),
            expectActiveEvent(call)
              .then(() => {
                assert.property(call, 'roomId');
                assert.isHydraID(call.roomId);
                assert.equal(call.roomId, conversationUrl);
              })
          ])));
        });
      });
    });
  });
});
