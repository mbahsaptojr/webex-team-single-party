{"version":3,"sources":["audio.js"],"names":["handleTransition","audio","mute","self","MEETING_AUDIO_STATE_MACHINE","STATES","MUTE_SELF","UNMUTE_SELF","triggerEvent","meeting","state","result","trigger","type","status","muted","doToggle","transition","MeetingUtil","remoteUpdateAudioVideo","video","then","resolution","Media","setLocalTracks","mediaProperties","localStream","error","catch","remoteUpdateError","console","log","event","EVENT_TRIGGERS","MEDIA_AUDIO_CHANGED","EVENT_TYPES","ERROR","reject","LOCAL","from","to","resolve","AudioStateMachine","create","mediaDirection","sendAudio","StateMachine","transitions","name","TRANSITIONS","TOGGLE","data","methods","isMuted","isSelf","setData","onBeforeToggle","onAfterToggle","plugins","StateMachineHistory","max"],"mappings":"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","file":"audio.js","sourcesContent":["/* eslint-disable no-console */\n\nimport StateMachine from 'javascript-state-machine';\nimport StateMachineHistory from 'javascript-state-machine/lib/history';\n\nimport Media from '../media';\nimport MeetingUtil from '../meeting/util';\nimport {MEETING_AUDIO_STATE_MACHINE, EVENT_TRIGGERS, EVENT_TYPES} from '../constants';\n\nconst handleTransition = (audio) => {\n  if (audio.mute && audio.self) {\n    return MEETING_AUDIO_STATE_MACHINE.STATES.MUTE_SELF;\n  }\n  if (!audio.mute && audio.self) {\n    return MEETING_AUDIO_STATE_MACHINE.STATES.UNMUTE_SELF;\n  }\n  return null;\n};\n\nconst triggerEvent = (meeting, state, result, trigger, type) => {\n  meeting.trigger(trigger, {\n    type,\n    status: state.state,\n    muted: state.muted,\n    result\n  });\n};\n\nconst doToggle = (state, transition, audio, meeting) => {\n  MeetingUtil.remoteUpdateAudioVideo(audio, {mute: meeting.video.muted}, meeting)\n    .then((resolution) => {\n      try {\n        Media.setLocalTracks(audio, {mute: meeting.video.muted}, meeting.mediaProperties.localStream);\n      }\n      catch (error) {\n        MeetingUtil.remoteUpdateAudioVideo({mute: state.muted}, {mute: meeting.video.muted}, meeting).catch(\n          (remoteUpdateError) => {\n            console.log(\n              `audio:state#onBeforeToggle->${transition.event} fired! State failed to change with transition '${\n                transition.transition\n              }''. After local audio toggle failed, resetting remote also failed, meeting audio in bad state with error: ${remoteUpdateError}.`\n            );\n          }\n        );\n        triggerEvent(meeting, state, error, EVENT_TRIGGERS.MEDIA_AUDIO_CHANGED, EVENT_TYPES.ERROR);\n        console.log(\n          `audio:state#onBeforeToggle->${transition.event} fired! State failed to change with transition '${\n            transition.transition\n          }''. State has been reset and toggling has been reversed.`\n        );\n        return Promise.reject(error);\n      }\n      triggerEvent(meeting, state, resolution, EVENT_TRIGGERS.MEDIA_AUDIO_CHANGED, EVENT_TYPES.LOCAL);\n      console.log(\n        `audio:state#onAfterToggle->${transition.event} fired! State changed from '${transition.from}' to '${\n          transition.to\n        }' with transition '${transition.transition}''.`\n      );\n      return Promise.resolve(resolution);\n    })\n    .catch((error) => {\n      triggerEvent(meeting, state, error, EVENT_TRIGGERS.MEDIA_AUDIO_CHANGED, EVENT_TYPES.ERROR);\n      console.log(\n        `audio:state#onAfterHistoryBack->${transition.event} fired! State failed to change with transition '${\n          transition.transition\n        }''. State has been reset and toggling has been reversed.`\n      );\n      return Promise.reject(error);\n    });\n};\n\nconst AudioStateMachine = {\n  /**\n   *\n   * @param {Object} mediaDirection An object that contains whether we send audio/video/screen streams\n   * @param {Meeting} meeting the meeting instance we are using for this state machine\n   * @returns {StateMachine} returns a StateMachine instance\n   */\n  create(mediaDirection, meeting) {\n    if (!mediaDirection.sendAudio) {\n      return null;\n    }\n    return new StateMachine({\n      transitions: [\n        {\n          name: MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.TOGGLE,\n          from: '*',\n          /**\n           *\n           * @param {Object} audio The audio options\n           * @param {Boolean} audio.mute Whether to mute the meeting or not\n           * @param {Boolean} audio.self Whether the was muted by the end user\n           * @param {Boolean} audio.remote Whether the meeting was muted by the server\n           * @returns {String} returns a new value to set the state to\n           */\n          to(audio) {\n            return handleTransition(audio) || this.state;\n          }\n        }\n      ],\n      data: {\n        muted: false,\n        self: true\n      },\n      methods: {\n        /**\n         * Convenience method to return whether the call is muted or not\n         * @returns {Boolen} whether the audio is muted or not\n         */\n        isMuted() {\n          return this.muted;\n        },\n\n        /**\n         * Convenience method to expose this.self\n         * @returns {Boolen} this.self\n         */\n        isSelf() {\n          return this.self;\n        },\n\n        /**\n         *\n         * @param {Object} audio the audio state to change\n         * @returns {null}\n         */\n        setData(audio) {\n          this.muted = audio.mute;\n          this.self = audio.self;\n        },\n\n        /**\n         * Method that gets fired before the toggle state change.\n         * If this fails, return false will cancel the transition and the state will remain unchanged\n\n         * @param {Object} transition the StateMachine transition object\n         * @param {Object} audio Audio options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onBeforeToggle(transition, audio) {\n          if (transition.from !== transition.to) {\n            doToggle(this, transition, audio, meeting);\n          }\n          return Promise.resolve(this.data);\n        },\n\n        /**\n         *\n         * @param {Object} transition StateMachine transition\n         * @param {Object} audio audio options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onAfterToggle(transition, audio) {\n          this.setData(audio);\n          return Promise.resolve(this.data);\n        },\n        plugins: [new StateMachineHistory({max: 5})]\n      }\n    });\n  }\n};\n\nexport default AudioStateMachine;\n"]}