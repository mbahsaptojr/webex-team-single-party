'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MeetingUtil = {};

MeetingUtil.parseLocusJoin = function (response) {
  var parsed = {};
  // First todo: add check for existance
  parsed.locus = response.body.locus;
  parsed.mediaConnections = response.body.mediaConnections;
  parsed.locusUrl = parsed.locus.url;
  parsed.locusId = parsed.locus.url.split('/').pop();
  parsed.selfId = parsed.locus.self.id;

  // we need mediaId before making roap calls
  parsed.mediaConnections.forEach(function (mediaConnection) {
    if (mediaConnection.mediaId) {
      parsed.mediaId = mediaConnection.mediaId;
    }
  });
  return parsed;
};

MeetingUtil.getLocusPartner = function (participants, self) {
  return participants.find(function (participant) {
    return self && participant.identity !== self.identity && (participants.length <= 2 || participant.type === _constants.USER && !participant.removed);
  }) || undefined.partner;
};

MeetingUtil.remoteUpdateAudioVideo = function (audio, video, meeting) {
  if (!meeting) {
    return _promise2.default.reject(new Error('You need a meeting object.'));
  }
  var localMedias = _media2.default.generateLocalMedias(meeting.mediaId, audio, video);
  if ((0, _isEmpty3.default)(localMedias)) {
    return _promise2.default.reject(new Error('You need a media id on the meeting to change remote audio.'));
  }
  return meeting.meetingRequest.remoteAudioVideoToggle({
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    localMedias: localMedias,
    deviceUrl: meeting.deviceUrl,
    correlationId: meeting.correlationId
  });
};

MeetingUtil.leaveMeeting = function (meeting) {
  if (!meeting) {
    return _promise2.default.reject(new Error('You need a meeting object.'));
  }
  return meeting.meetingRequest.leaveMeeting({
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    correlationId: meeting.correlationId,
    resourceId: null,
    deviceUrl: meeting.deviceUrl
  });
};

// TODO: have locus ignore hostPin if they find out it's my claimed PMR
/*
for my claimed PMR
passing an "undefined" hostPin was causing the issue.
if I don't include hostPin in the first request, locus figures out it's my PMR
and sends a 200 after the first request
so we must clean up the hostPin to stop the double request
*/
MeetingUtil.cleanOptions = function (options, info, owner, userId) {
  if (MeetingUtil.hasOwner(info)) {
    if (MeetingUtil.isOwnerSelf(owner, userId)) {
      if (options.hostPin) {
        delete options.hostPin;
      }
      options.moderator = _constants.MODERATOR_TRUE;
    } else {
      options.moderator = _constants.MODERATOR_FALSE;
    }
  }
  return options;
};

MeetingUtil.hasOwner = function (info) {
  return info && info.owner;
};

MeetingUtil.isOwnerSelf = function (owner, selfId) {
  return owner === selfId;
};

MeetingUtil.isPinOrGuest = function (err) {
  if (err && err.body && err.body.errorCode === _constants.INTENT_TO_JOIN) {
    return true;
  }
  return false;
};

MeetingUtil.joinMeeting = function (meeting, options) {
  if (!meeting) {
    return _promise2.default.reject(new Error('You need a meeting object.'));
  }
  // eslint-disable-next-line no-warning-comments
  // TODO: check if the meeting is in JOINING state
  // if Joining state termintate the request as user might click multiple times
  return meeting.meetingRequest.joinMeeting({
    sipUri: meeting.sipUri,
    deviceUrl: meeting.deviceUrl,
    locusUrl: meeting.locusUrl,
    correlationId: meeting.id,
    resourceId: meeting.resourceId,
    moderator: options.moderator,
    hostPin: options.hostPin
  }).then(function (res) {
    return MeetingUtil.parseLocusJoin(res);
  });
};

MeetingUtil.getSdps = function (meeting) {
  var sdps = [];

  if (meeting.mediaProperties.mediaPeerConnection) {
    sdps.push(meeting.mediaProperties.mediaPeerConnection.sdp);
  }

  if (meeting.mediaProperties.sharePeerConnection) {
    sdps.push(meeting.mediaProperties.sharePeerConnection.sdp);
  }

  return sdps;
};

exports.default = MeetingUtil;
//# sourceMappingURL=util.js.map
