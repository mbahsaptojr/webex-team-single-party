'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _sparkCore = require('@ciscospark/spark-core');

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class MeetingRequest
 */
var MeetingRequest = function (_StatelessSparkPlugin) {
  (0, _inherits3.default)(MeetingRequest, _StatelessSparkPlugin);

  function MeetingRequest() {
    (0, _classCallCheck3.default)(this, MeetingRequest);
    return (0, _possibleConstructorReturn3.default)(this, (MeetingRequest.__proto__ || (0, _getPrototypeOf2.default)(MeetingRequest)).apply(this, arguments));
  }

  (0, _createClass3.default)(MeetingRequest, [{
    key: 'joinMeeting',

    /**
     * Make a network request to join a meeting
     * @param {Object} options
     * @param {String} options.sipUri
     * @param {String} options.deviceUrl
     * @param {String} options.locusUrl
     * @param {String} options.resourceId,
     * @param {String} options.correlationId
     * @returns {Promise}
     */
    value: function joinMeeting(options) {
      var sipUri = options.sipUri,
          deviceUrl = options.deviceUrl,
          locusUrl = options.locusUrl,
          resourceId = options.resourceId,
          correlationId = options.correlationId,
          ensureConversation = options.ensureConversation,
          moderator = options.moderator,
          hostPin = options.hostPin;


      var url = '';

      var body = {
        deviceUrl: deviceUrl,
        usingResource: resourceId || null,
        correlationId: correlationId,
        respOnlySdp: true,
        allowMultiDevice: true,
        ensureConversation: ensureConversation || false,
        supportsNativeLobby: 1
      };

      if (moderator !== undefined) {
        body.moderator = moderator;
      }

      if (hostPin !== undefined) {
        body.hostPIN = hostPin;
      }

      if (locusUrl) {
        url = locusUrl + '/' + _constants.PARTICIPANT;
      } else if (sipUri) {
        // eslint-lin-disable-next-line no-warning-comments
        // TODO switch to use the locus object and look into federation?
        url = this.spark.internal.device.services.locusServiceUrl + '/' + _constants.LOCI + '/' + _constants.CALL;
        body.invitee = {
          address: sipUri
        };
      }

      if (resourceId === sipUri) {
        body.callPreferences = {
          requestedMedia: ['SLIDES']
        };
      }

      return this.spark.request({
        method: _constants.POST,
        uri: url,
        qs: { alternateRedirect: true }, // for handling locus URL redirections
        body: body
      });
    }

    /**
     * Syns the missed delta event
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.syncUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: 'syncMeeting',
    value: function syncMeeting(options) {
      /* eslint-disable no-else-return */
      var desync = options.desync;
      var syncUrl = options.syncUrl;
      /* istanbul ignore else */

      if (desync) {
        // check for existing URL parameters
        syncUrl = syncUrl.concat(syncUrl.split('?')[1] ? '&' : '?').concat(_constants.LOCUS.SYNCDEBUG + '=' + desync);
      }
      return this.request({
        method: _constants.GET,
        uri: syncUrl
      }) // TODO: Handle if delta sync failed . Get the full locus object
      .catch(function (err) {
        return err;
      });
    }

    /**
     * Request to get the complete locus object
     * @param {Object} options
     * @param {boolen} options.desync flag to get partial or whole locus object
     * @param {String} options.locusUrl sync url to get ht elatest locus delta
     * @returns {Promise}
     */

  }, {
    key: 'getFullLocus',
    value: function getFullLocus(options) {
      var locusUrl = options.locusUrl;
      var desync = options.desync;


      if (locusUrl) {
        if (desync) {
          locusUrl += '?' + _constants.LOCUS.SYNCDEBUG + '=' + desync;
        }
        return this.request({
          method: _constants.GET,
          uri: locusUrl
        }).catch(function (err) {
          console.error('error getting full locus object', err);
        });
      }
      return _promise2.default.reject();
    }

    /**
     * Make a network request to leave a meeting
     * @param {Object} options
     * @param {String} options.deviceUrl
     * @param {String} options.resourceId,
     * @param {String} options.correlationId
     * @returns {Promise}
     */

  }, {
    key: 'leaveMeeting',
    value: function leaveMeeting(options) {
      var url = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + options.selfId + '/' + _constants.LEAVE;
      var body = {
        deviceUrl: options.deviceUrl,
        usingResource: options.resourceId,
        correlationId: options.correlationId
      };
      return this.request({
        method: _constants.PUT,
        uri: url,
        body: body
      });
    }

    /**
     * Make a network request to acknowledge a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.id
     * @returns {Promise}
     */

  }, {
    key: 'acknowledgeMeeting',
    value: function acknowledgeMeeting(options) {
      var uri = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + _constants.ALERT;
      var body = {
        deviceUrl: options.deviceUrl,
        correlationId: options.id
      };
      return this.request({
        method: _constants.PUT,
        uri: uri,
        body: body
      });
    }

    /**
     * Make a network request to decline a meeting
     * @param {Object} options
     * @param {String} options.locusUrl
     * @param {String} options.deviceUrl
     * @param {String} options.reason
     * @returns {Promise}
     */

  }, {
    key: 'declineMeeting',
    value: function declineMeeting(options) {
      var uri = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + _constants.DECLINE;
      var body = {
        deviceUrl: options.deviceUrl,
        reason: options.reason
      };
      return this.request({
        method: _constants.PUT,
        uri: uri,
        body: body
      });
    }

    /**
     * Toggle remote audio and/or video
     * @param {Object} options options for toggling
     * @param {String} options.selfId Locus self id??
     * @param {String} options.locusUrl Locus url
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.localMedias local sdps
     * @returns {Promise}
     */

  }, {
    key: 'remoteAudioVideoToggle',
    value: function remoteAudioVideoToggle(options) {
      var url = options.locusUrl + '/' + _constants.PARTICIPANT + '/' + options.selfId + '/' + _constants.MEDIA;
      var body = {
        deviceUrl: options.deviceUrl,
        usingResource: options.resourceId || null,
        correlationId: options.correlationId,
        respOnlySdp: true,
        localMedias: options.localMedias
      };
      return this.request({
        method: _constants.PUT,
        uri: url,
        body: body
      });
    }

    /**
     * change the content floor grant
     * @param {Object} options options for floor grant
     * @param {String} options.disposition floor action (granted/released)
     * @param {String} options.personUrl personUrl who is requesting floor
     * @param {String} options.deviceUrl Url of a device
     * @param {String} options.resourceId Populated if you are paired to a device
     * @param {String} options.uri floor grant uri
     * @returns {Promise}
     */

  }, {
    key: 'changeMeetingFloor',
    value: function changeMeetingFloor(options) {
      var floorReq = { disposition: options.disposition };
      /* istanbul ignore else */
      if (options.disposition === _constants.FLOOR_ACTION.GRANTED) {
        floorReq = {
          beneficiary: {
            url: options.personUrl,
            devices: [{ url: options.deviceUrl }]
          },
          disposition: options.disposition,
          requester: {
            url: options.personUrl
          }
        };
      }

      return this.request({
        uri: options.uri,
        method: _constants.PUT,
        body: {
          floor: floorReq,
          resourceUrl: options.resourceUrl
        }
      });
    }
  }]);
  return MeetingRequest;
}(_sparkCore.StatelessSparkPlugin);

exports.default = MeetingRequest;
//# sourceMappingURL=request.js.map
