'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _sparkCore = require('@ciscospark/spark-core');

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _index = require('../roap/index');

var _index2 = _interopRequireDefault(_index);

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

var _properties = require('../media/properties');

var _properties2 = _interopRequireDefault(_properties);

var _state = require('../meeting/state');

var _state2 = _interopRequireDefault(_state);

var _audio = require('../meeting/audio');

var _audio2 = _interopRequireDefault(_audio);

var _video = require('../meeting/video');

var _video2 = _interopRequireDefault(_video);

var _locusInfo = require('../locus-info');

var _locusInfo2 = _interopRequireDefault(_locusInfo);

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

var _reconnectionManager = require('../reconnection-manager');

var _reconnectionManager2 = _interopRequireDefault(_reconnectionManager);

var _request = require('../meeting/request');

var _request2 = _interopRequireDefault(_request);

var _index3 = require('../members/index');

var _index4 = _interopRequireDefault(_index3);

var _util = require('../meeting/util');

var _util2 = _interopRequireDefault(_util);

var _index5 = require('../stats/index');

var _index6 = _interopRequireDefault(_index5);

var _intentToJoin = require('../errors/intent-to-join');

var _intentToJoin2 = _interopRequireDefault(_intentToJoin);

var _joinMeeting = require('../errors/join-meeting');

var _joinMeeting2 = _interopRequireDefault(_joinMeeting);

var _reconnection = require('../errors/reconnection');

var _reconnection2 = _interopRequireDefault(_reconnection);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
  * Media Ready Event
  * Emitted when a stream is ready to be rendered
  * @event media:ready
  * @instance
  * @type {Object}
  * @property {MediaStream} stream the media stream
  * @property {String} type what type of stream, remote, local
  * @memberof Meetings
  */

/**
  * Media Stopped Event
  * Emitted when a stream has stopped sending
  * @event media:stopped
  * @instance
  * @type {Object}
  * @property {String} type what type of stream, remote, local
  * @memberof Meetings
  */

/**
  * Reconnection Success Event
  * Emitted when reconnection of media to the active meeting was successful
  * @event meeting:reconnectionSuccess
  * @instance
  * @type {Object}
  * @property {Object} reconnect
  * @memberof Meetings
  */

/**
  * Reconnection Failure Event
  * Emitted when reconnection of media to the active meeting was successful
  * @event meeting:reconnectionFailure
  * @instance
  * @type {Object}
  * @property {Error} error
  * @memberof Meetings
  */

/**
  * Ringing Event
  * Emitted when a ring should occur or stop, outgoing or incoming
  * @event meeting:reconnectionFailure
  * @instance
  * @type {Object}
  * @property {String} type indicating if it's out or in
  * @property {Boolean} ringing if it should ring or not
  * @memberof Meetings
  */

/**
 * @class Meeting
 */
var Meeting = function (_StatelessSparkPlugin) {
  (0, _inherits3.default)(Meeting, _StatelessSparkPlugin);

  /**
   * Create an instance of Meeting
   *
   * @param {Object} attrs
   * @param {Object} options
   * @constructor
   * @memberof Meeting
   */
  function Meeting(attrs, options) {
    (0, _classCallCheck3.default)(this, Meeting);

    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Meeting.__proto__ || (0, _getPrototypeOf2.default)(Meeting)).call(this, {}, options));

    _this.namespace = _constants.MEETINGS;

    _this.getMediaStreams = function (mediaDirection) {
      return _media2.default.getUserMedia(mediaDirection);
    };

    _this.attrs = attrs;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.options = options;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.id = _uuid2.default.v4();
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.userId = attrs.userId;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.resource = attrs.resource;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.deviceUrl = attrs.deviceUrl;
    /**
     * @instance
     * @type {Number}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.roapSeq = 0;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @public
     * @todo needs to be defined as a class
     * @memberof Meeting
     */
    _this.meetingInfo = {};
    /**
     * @instance
     * @type {Members}
     * @public
     * @memberof Meeting
     */
    _this.members = new _index4.default({}, { parent: _this.spark });
    /**
     * @instance
     * @type {Roap}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.roap = new _index2.default({}, options);
    /**
     * created later
     * @instance
     * @type {ReconnectionManager}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.reconnectionManager = null;
    /**
     * created later
     * @instance
     * @type {AudioStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.audio = null;
    /**
     * created later
     * @instance
     * @type {VideoStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.video = null;
    /**
     * @instance
     * @type {MeetingStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.state = _state2.default.create(_this);
    /**
     * created later on user demand
     * @instance
     * @type {WebRTCStats}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.stats = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.convoId = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.locusUrl = attrs.locus && attrs.locus.url || null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.sipUri = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.partner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.type = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.owner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.hostId = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.policy = null;
    /**
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    _this.meetingRequest = new _request2.default({}, options);
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    _this.locusInfo = new _locusInfo2.default(_this.updateMeetingObject.bind(_this), attrs.locus ? attrs.locus : {}, _this.spark);
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MediaProperties}
     * @public
     * @memberof Meeting
     */
    _this.mediaProperties = new _properties2.default();
    _this.setUpLocusInfoListeners();
    return _this;
  }

  /**
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */


  (0, _createClass3.default)(Meeting, [{
    key: 'setUpLocusInfoListeners',
    value: function setUpLocusInfoListeners() {
      this.setUpLocusInfoSelfListener();
    }

    /**
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusInfoSelfListener',
    value: function setUpLocusInfoSelfListener() {
      var _this2 = this;

      _events2.default.on(_constants.EVENTS.SELF_UNADMITTED_GUEST, function (payload) {
        if (payload) {
          _this2.trigger(_constants.EVENT_TRIGGERS.MEETING_SELF_LOBBY_WAITING, {
            payload: payload
          });
        }
      });
      _events2.default.on(_constants.EVENTS.SELF_ADMITTED_GUEST, function (payload) {
        if (payload) {
          _this2.trigger(_constants.EVENT_TRIGGERS.MEETING_SELF_GUEST_ADMITTED, {
            payload: payload
          });
        }
      });
    }

    /**
     * @param {Object} object
     * @returns {undefined}
     * @private
     * @memberof Meeting
     * // TODO: is this function necessary?
     */

  }, {
    key: 'updateMeetingObject',
    value: function updateMeetingObject(object) {
      var _this3 = this;

      // Validate if these are valid meeting object property
      // TODO: add a check to make sure the value passed in the constructor
      // is not changed by any delta event
      if (object && (0, _keys2.default)(object).length) {
        (0, _keys2.default)(object).forEach(function (key) {
          _this3[key] = object[key];
        });
      }
    }

    /**
     * invite a guest to the call that isn't normally part of this call
     * @param {Object} invitee
     * @param {String} invitee.emailAddress
     * @param {String} invitee.email
     * @param {Boolean} alertIfActive optional
     * @returns {Promise} see #members.addMember
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'invite',
    value: function invite(invitee) {
      var alertIfActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.members.addMember(invitee, alertIfActive);
    }

    /**
     * admit the guest(s) to the call once they are waiting
     * @param {Array} memberIds
     * @returns {Promise} see #members.admitMembers
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'admit',
    value: function admit(memberIds) {
      return this.members.admitMembers(memberIds);
    }

    /**
     * Reference to the Members object
     * @returns {Members}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'getMembers',
    value: function getMembers() {
      return this.members;
    }

    /**
     * Reference to the stats builder object
     * @param {Object} options - optional
     * @param {Object} options.media
     * @param {Object} options.screen
     * @returns {WebRTCStats}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'getStats',
    value: function getStats(options) {
      if (!this.stats) {
        return this.createStats(options);
      }
      return this.stats;
    }

    /**
     * Overwrite the stats builder object
     * @param {Object} options - optional
     * @param {Object} options.media
     * @param {Object} options.screen
     * @returns {WebRTCStats}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'createStats',
    value: function createStats() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.stats = new _index6.default(this.attrs, this.options, options);
      return this.stats;
    }

    /**
     * Convenience function to tell whether a meeting is muted
     * @returns {Boolean} if meeting audio muted or not
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isAudioMuted',
    value: function isAudioMuted() {
      return this.audio && this.audio.isMuted();
    }

    /**
     * Convenience function to tell if the end user last changed the audio state
     * @returns {Boolean} if audio was manipulated by the end user
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isAudioSelf',
    value: function isAudioSelf() {
      return this.audio && this.audio.isSelf();
    }

    /**
     * Convenience function to tell whether video is muted
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isVideoMuted',
    value: function isVideoMuted() {
      return this.video && this.video.isMuted();
    }

    /**
     * Convenience function to tell whether the end user changed the video state
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isVideoSelf',
    value: function isVideoSelf() {
      return this.video && this.video.isSelf();
    }

    /**
     * Sets the meeting info on the class instance
     * @param {Object} meetingInfo
     * @param {String} meetingInfo.convoId
     * @param {String} meetingInfo.locusUrl
     * @param {String} meetingInfo.sipUri
     * @param {Object} meetingInfo.owner
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'parseMeetingInfo',
    value: function parseMeetingInfo(meetingInfo) {
      // MeetingInfo will be undefined for 1:1 calls
      if (meetingInfo && meetingInfo.body && !(meetingInfo.errors && meetingInfo.errors.length > 0)) {
        this.convoId = meetingInfo.body.convoId || this.convoId;
        this.locusUrl = meetingInfo.body.locusUrl || this.locusUrl;
        this.sipUri = meetingInfo.body.sipMeetingUri || this.sipUri;
        this.owner = meetingInfo.body.owner || this.owner;
      }
    }

    /**
     * Sets the first locus info on the class instance
     * @param {Object} locus
     * @param {String} locus.url
     * @param {Array} locus.participants
     * @param {Object} locus.self
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'parseLocus',
    value: function parseLocus(locus) {
      if (locus) {
        this.locusUrl = locus.url;
        // TODO: move this to parse participants module
        this.setLocus(locus);

        // check if we can extract this info from partner
        // Parsing of locus object must be finished at this state
        if (locus.participants && locus.self) {
          this.partner = _util2.default.getLocusPartner(locus.participants, locus.self);
        }

        // For webex meeting the sipUrl gets updated in info parser
        if (!this.sipUri && this.partner && this.type === _constants.ONE_ON_ONE) {
          this.sipUri = this.partner.person.sipUrl || this.partner.person.emailAddress || this.partner.person.email;
        }
      }
    }

    /**
     * Sets the sip uri on the class instance
     * uses meeting info as precedence
     * @param {String} sipUri
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setSipUri',
    value: function setSipUri(sipUri) {
      // This can be tel no, device id or a sip uri, user Id
      this.sipUri = sipUri;
    }

    /**
     * Set the roap seq on the class instance
     * @param {Number} seq
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setRoapSeq',
    value: function setRoapSeq(seq) {
      if (seq) {
        this.roapSeq = seq;
      }
    }

    /**
     * Set the locus info the class instance
     * @param {Object} locus
     * @param {Array} locus.mediaConnections
     * @param {String} locus.locusUrl
     * @param {String} locus.locusId
     * @param {String} locus.mediaId
     * @param {Object} locus.host
     * @todo change name to genertic parser
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setLocus',
    value: function setLocus(locus) {
      var mtgLocus = locus.locus || locus;
      // LocusInfo object saves the locus object
      // this.locus = mtgLocus;
      this.mediaConnections = locus.mediaConnections;
      this.locusUrl = locus.locusUrl || locus.url;
      this.locusId = locus.locusId;
      this.selfId = locus.selfId;
      this.mediaId = locus.mediaId;
      this.hostId = mtgLocus.host ? mtgLocus.host.id : this.hostId;
      this.locusInfo.initialSetup(mtgLocus);
    }

    /**
     * Sets the remote stream on the class instance and emits and
     * event to developers
     * @param {Object} pc The remote stream peer connection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setRemoteStream',
    value: function setRemoteStream(pc) {
      var _this4 = this;

      if (!pc) {
        return;
      }
      // eslint-disable-next-line no-param-reassign
      pc.ontrack = function (event) {

        // eslint-disable-next-line no-warning-comments
        // TODO: It's possible for media to not be present
        // so we might need to either
        // A) wait until we have media flowing
        // B) trigger a second event when video is flowing
        var _event$streams = (0, _slicedToArray3.default)(event.streams, 1);

        _this4.mediaProperties.remoteStream = _event$streams[0];
        _this4.trigger(_constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.REMOTE,
          stream: _this4.mediaProperties.remoteStream
        });
      };
    }

    /**
     * Removes the remote stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetRemoteStream',
    value: function unsetRemoteStream() {
      this.mediaProperties.unsetRemoteStream();
    }

    /**
     * Removes the remote stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closeRemoteStream',
    value: function closeRemoteStream() {
      var _this5 = this;

      return _media2.default.stopStream(this.mediaProperties.remoteStream).then(function () {
        _this5.trigger(_constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: _constants.EVENT_TYPES.REMOTE
        });
      });
    }

    /**
     * Sets the sceen stream on the class instance and triggers and event to developers
     * @param {Object} pc a peer connection instance for the screen
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setShareStream',
    value: function setShareStream(pc) {
      var _this6 = this;

      if (!pc) {
        return;
      }
      // eslint-disable-next-line no-param-reassign
      pc.ontrack = function (event) {
        var _event$streams2 = (0, _slicedToArray3.default)(event.streams, 1);

        _this6.mediaProperties.remoteShare = _event$streams2[0];


        _this6.trigger(_constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.REMOTE_SHARE,
          stream: _this6.mediaProperties.remoteShare
        });
      };
    }

    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {Stream} localStream the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setLocalStream',
    value: function setLocalStream(localStream) {
      if (localStream) {
        this.mediaProperties.setLocalStream(localStream);
        this.trigger(_constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.LOCAL,
          stream: this.mediaProperties.localStream
        });
      }
    }

    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {Stream} localShare the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setLocalShare',
    value: function setLocalShare(localShare) {
      var _this7 = this;

      if (localShare) {
        this.mediaProperties.setLocalShare(localShare);
        var contentTracks = this.mediaProperties.localShare.getVideoTracks();
        contentTracks.forEach(function (track) {
          track.onended = function () {
            _this7.stopShare();
          };
        });

        this.trigger(_constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.LOCAL_SHARE,
          stream: this.mediaProperties.localShare
        });
      }
    }

    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closeLocalStream',
    value: function closeLocalStream() {
      var _this8 = this;

      return _media2.default.stopStream(this.mediaProperties.localStream).then(function () {
        _this8.trigger(_constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: _constants.EVENT_TYPES.LOCAL
        });
      });
    }

    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closeLocalShare',
    value: function closeLocalShare() {
      var _this9 = this;

      return _media2.default.stopStream(this.mediaProperties.localShare).then(function () {
        _this9.trigger(_constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: _constants.EVENT_TYPES.LOCAL_SHARE
        });
      });
    }

    /**
     * Removes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetLocalStream',
    value: function unsetLocalStream() {
      this.mediaProperties.unsetLocalStream();
    }

    /**
     * Removes the local share from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetLocalShare',
    value: function unsetLocalShare() {
      this.mediaProperties.unsetLocalShare();
    }

    /**
     * Sets the peer connections on the class
     * sets up reconnection logic
     * @param {PeerConnection} mediaPeerConnection
     * @param {PeerConnection} sharePeerConnection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setPeerConnections',
    value: function setPeerConnections(mediaPeerConnection, sharePeerConnection) {
      var _this10 = this;

      this.mediaProperties.setPeerConnections(mediaPeerConnection, sharePeerConnection);
      // TODO: need to test more with the triggers for reconnect, we also need to add triggers based on getStats reports
      if (this.config.reconnection.detection) {
        this.reconnectionManager = new _reconnectionManager2.default(this);
        _peerConnectionManager2.default.detectFailures(this.mediaProperties.mediaPeerConnection, this.mediaProperties.sharePeerConnection, this.reconnect);
        // Client will have a socket manager and handle reconnecting to mercury, when we reconnect to mercury
        // if the meeting has active peer connections, it should try to reconnect.
        this.spark.internal.mercury.on(_constants.ONLINE, function () {
          _this10.reconnect();
        });
      }
    }

    /**
     * Close the peer connections and remove them from the class. Triggers an event
     * when each is closed.
     * @returns {Promise} returns a resolved promise with an array of closed peer connections
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closePeerConnections',
    value: function closePeerConnections() {
      return _promise2.default.all([_peerConnectionManager2.default.close(this.mediaProperties.mediaPeerConnection), _peerConnectionManager2.default.close(this.mediaProperties.sharePeerConnection)]);
    }

    /**
     * Unsets the peer connections on the class
     * warning DO NOT CALL WITHOUT CLOSING PEER CONNECTIONS FIRST
     * @param {PeerConnection} mediaPeerConnection
     * @param {PeerConnection} sharePeerConnection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetPeerConnections',
    value: function unsetPeerConnections() {
      this.mediaProperties.unsetPeerConnections();
      if (this.config.reconnection.detection) {
        this.spark.internal.mercury.off(_constants.ONLINE);
      }
    }

    /**
     * Convenience method to set the correlation id for the Meeting
     * @param {String} id correlation id to set on the class
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setCorrelationId',
    value: function setCorrelationId(id) {
      this.correlationId = id;
    }

    /**
     * Mute the audio for a meeting
     * @returns {Promise} resolves the data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'muteAudio',
    value: function muteAudio() {
      if (!this.audio || this.audio && !this.audio.toggle) {
        return _promise2.default.reject(new Error('no audio control associated to the meeting'));
      }
      return this.audio.toggle({
        mute: true,
        self: true
      });
    }

    /**
     * Unmute meeting audio
     * @returns {Promise} resolves data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unmuteAudio',
    value: function unmuteAudio() {
      if (!this.audio || this.audio && !this.audio.toggle) {
        return _promise2.default.reject(new Error('no audio control associated to the meeting'));
      }
      return this.audio.toggle({
        mute: false,
        self: true
      });
    }

    /**
     * Mute the video for a meeting
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'muteVideo',
    value: function muteVideo() {
      if (!this.video || this.video && !this.video.toggle) {
        return _promise2.default.reject(new Error('no video control associated to the meeting'));
      }
      return this.video.toggle({
        mute: true,
        self: true
      });
    }

    /**
     * Unmute meeting video
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unmuteVideo',
    value: function unmuteVideo() {
      if (!this.video || this.video && !this.video.toggle) {
        return _promise2.default.reject(new Error('no audio control associated to the meeting'));
      }
      var options = {};
      options.mute = false;
      options.self = true;
      return this.video.toggle({
        mute: false,
        self: true
      });
    }

    /**
     * @param {Object} joinOptions - see #join()
     * @param {Object} mediaOptions - see #addMedia()
     * @param {object} streamsOptions - see #getMediaStreams()
     * @returns {Promise} -- {join: see join(), media: see addMedia(), local: see getMediaStreams()}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'joinWithMedia',
    value: function joinWithMedia(joinOptions, mediaOptions, streamsOptions) {
      var _this11 = this;

      this.join(joinOptions).then(function (joinResponse) {
        return _this11.getMediaStreams(streamsOptions).then(function (_ref) {
          var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
              localStream = _ref2[0],
              localShare = _ref2[1];

          return _this11.addMedia({
            mediaSettings: mediaOptions,
            localShare: localShare,
            localStream: localStream
          }).then(function (mediaResponse) {
            _promise2.default.resolve({
              join: joinResponse,
              media: mediaResponse,
              local: [localStream, localShare]
            });
          });
        });
      }).catch(function (error) {
        return _promise2.default.reject(error);
      });
    }

    /**
     * initiates the reconnection of the media in the meeting
     * @returns {Promise} resolves with {reconnect} or errors with {error}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'reconnect',
    value: function reconnect() {
      var _this12 = this;

      if (!this.reconnectionManager || !this.reconnectionManager.reconnect) {
        throw new Error('Cannot reconnect, ReconnectionManager must first be defined.');
      }
      return this.reconnectionManager.reconnect(this).then(function (reconnect) {
        _this12.trigger(_constants.EVENT_TRIGGERS.MEETING_RECONNECTION_SUCCESS, {
          reconnect: reconnect
        });
        return _promise2.default.resolve(reconnect);
      }).catch(function (error) {
        _this12.trigger(_constants.EVENT_TRIGGERS.MEETING_RECONNECTION_FAILURE, {
          error: new _reconnection2.default(error)
        });
        return _promise2.default.reject(new _reconnection2.default(error));
      }).finally(function (reconnect) {
        _this12.reconnectionManager.reset();
        return _promise2.default.resolve(reconnect);
      });
    }

    /**
     *
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {Object} options A configurable options object for joining a meeting
     * @param {String} options.resourceId pass the deviceId
     * @param {Number} options.hostPin pass the host pin
     * @param {Boolean} options.moderator pass the moderator flag
     * @returns {Promise} the join response
     * @public
     * @memberof Meeting
     * Scenario A: Joining own claimed personal meeting room, don't pass hostPin, do pass moderator
     * Scenario B: Joining other's claimed personal meeting room, do pass hostPin (if desired to join as host, or nullify), do pass moderator
     * Scenario C: Joining an unclaimed personal meeting room, -do not- pass hostPin or moderator on first try, -do- pass hostPin and moderator
     *             if joining as host on second loop, -do not- pass hostPin do pass moderator if joining as guest on second loop
     * Scenario D: Joining any other way (sip, pstn, convoId, link just need to specify resourceId)
     */

  }, {
    key: 'join',
    value: function join() {
      var _this13 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.ringing(_constants.STOP, false);
      this.resourceId = this.resourceId || options.resourceId;
      this.setCorrelationId(this.id);
      // this.state.join();
      // TODO: this should be removed following locus changes.
      options = _util2.default.cleanOptions(options, this.meetingInfo, this.owner, this.userId);
      // normal join meeting, scenario A, D
      return _util2.default.joinMeeting(this, options).then(function (response) {
        _this13.setLocus(response);
        return response;
        // this.state.connect();
      }).catch(function (err) {
        // joining a claimed PMR that is not my own, scenario B
        if (_util2.default.isPinOrGuest(err)) {
          if (_util2.default.hasOwner(_this13.meetingInfo)) {
            return _util2.default.joinMeeting(_this13, options).then(function (response) {
              _this13.setLocus(response);
              return response;
              // this.state.connect();
            });
          }
          // request host pin or non host for unclaimed PMR, start of Scenario C
          // see https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-Lobby-and--IVR-Feature
          return _promise2.default.reject(new _intentToJoin2.default(err));
        }
        _this13.logger.log('Meeting:index#join --> Error joining the call on getLocalMedia, ', err);
        return _promise2.default.reject(new _joinMeeting2.default(err, options));
      });
    }

    /**
     * get local media streams based on options passed
     * @param {Object} mediaDirection A configurable options object for joining a meeting
     * @returns {Promise} see #Media.getUserMedia
     * @public
     * @todo should be static
     * @memberof Meeting
     */

  }, {
    key: 'addMedia',


    /**
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {Object} options A configurable options object for joining a meeting
     * @param {Object} options.resourceId pass the deviceId
     * @param {MediaStream} options.localStream
     * @param {MediaStream} options.localShare
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    value: function addMedia() {
      var _this14 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var localStream = options.localStream,
          localShare = options.localShare;
      // eslint-disable-next-line no-warning-comments
      // TODO wire into default config. There's currently an issue with the stateless plugin or how we register

      this.mediaProperties.setMediaDirection((0, _assign2.default)(this.config.mediaSettings, options.mediaSettings));
      // add a setup a function move the create and setup media in future
      // TODO: delete old audio and video if stale
      this.audio = this.audio || _audio2.default.create(this.mediaProperties.mediaDirection, this);
      this.video = this.video || _video2.default.create(this.mediaProperties.mediaDirection, this);
      // this.state.local();
      this.setLocalStream(localStream);
      this.setLocalShare(localShare);
      return _media2.default.attachMedia(this.mediaProperties.mediaDirection, _peerConnectionManager2.default, localStream, localShare, {
        mediaPeerConnection: this.mediaProperties.mediaPeerConnection,
        sharePeerConnection: this.mediaProperties.sharePeerConnection
      }).then(function (_ref3) {
        var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
            mediaPeerConnection = _ref4[0],
            sharePeerConnection = _ref4[1];

        var updatedsharePeerConnection = _peerConnectionManager2.default.setContentSlides(sharePeerConnection);
        _this14.setPeerConnections(mediaPeerConnection, updatedsharePeerConnection);
        _this14.setRemoteStream(_this14.mediaProperties.mediaPeerConnection);
        _this14.setShareStream(_this14.mediaProperties.sharePeerConnection);
      }).catch(function (err) {
        _this14.logger.log('Meeting:index#join --> Error joining the call on roap initialization, ', err);
        throw err;
      }).then(function () {
        return _this14.roap.sendRoapMediaRequest({
          sdps: _util2.default.getSdps(_this14),
          roapSeq: _this14.roapSeq,
          meeting: _this14 // or can pass meeting ID
        }).catch(function (err) {
          _this14.logger.error('Meeting:index#join --> Error joining the call on send roap media request, ', err);
          throw err;
        });
      }).then(function () {
        // this.state.establish();
      });
    }

    /**
     * @param {String} type should be null if ringing is false
     * @param {Boolean} ringing coerced to null if false
     * @returns {undefined}
     * @event meeting:ringing
     * @memberof Meeting
     * TODO: move this to meeting state machine to manage ringing state
     */

  }, {
    key: 'ringing',
    value: function ringing(type) {
      var _ringing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.trigger(_constants.EVENT_TRIGGERS.MEETING_RINGING, {
        type: type,
        ringing: _ringing
      });
    }

    /**
     * acknowledge the meeting, outgoing or incoming
     * @param {String} type
     * @param {Boolean} ringing optional
     * @returns {Promise} resolve {message, ringing, response}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'acknowledge',
    value: function acknowledge(type) {
      var _this15 = this;

      var ringing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!type) {
        return _promise2.default.reject(new Error('Type must be set to acknowledge the meeting.'));
      }
      if (type === _constants.INCOMING) {
        return this.meetingRequest.acknowledgeMeeting({
          locusUrl: this.locusUrl,
          deviceUrl: this.deviceUrl,
          id: this.id
        }).then(function (response) {
          return _promise2.default.resolve(response);
        }).then(function (response) {
          _this15.ringing(type, ringing);
          return _promise2.default.resolve({
            message: 'Meeting type: ' + type + ' is acknowledged. Triggered ringing with: ' + ringing + '.',
            ringing: ringing,
            response: response
          });
        });
      }
      // TODO: outside of 1:1 incoming, and all outgoing calls
      return _promise2.default.resolve({
        message: 'noop'
      });
    }

    /**
     * Decline this meeting
     * @param {String} reason
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'decline',
    value: function decline() {
      var _this16 = this;

      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _constants.BUSY;

      return this.meetingRequest.declineMeeting({
        locusUrl: this.locusUrl,
        deviceUrl: this.deviceUrl,
        reason: reason
      }).then(function (response) {
        _this16.ringing(_constants.STOP, false);
        _events2.default.emit(_constants.EVENTS.DESTROY_MEETING_1_1, {
          meeting: _this16,
          response: response,
          type: _constants.EVENTS.DESTROY_MEETING_1_1
        });
      });
    }

    /**
     * Leave the current meeting
     * @param {Object} options An object of options
     * @param {Boolean} options.keepLocalMedia Whether to tear down the local media connections or not.
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'leave',
    value: function leave() {
      var _this17 = this;

      // this.state.leave();
      return this.meetingRequest.leaveMeeting({
        locusUrl: this.locusUrl,
        selfId: this.selfId,
        correlationId: this.correlationId,
        resourceId: null,
        deviceUrl: this.deviceUrl
      }).then(function () {
        return _this17.closeLocalStream();
      }).then(function () {
        return _this17.closeLocalShare();
      }).then(function () {
        return _this17.closePeerConnections();
      }).then(function () {
        _this17.unsetLocalStream();
        _this17.unsetLocalShare();
        _this17.unsetRemoteStream();
        _this17.unsetPeerConnections();
      }).then(function () {
        _this17.roap.stop(_this17.correlationId, _this17.roapSeq);
      }).then(function () {
        _this17.state.end();
      }).catch(function (err) {
        _this17.state.error();
        _this17.logger.error('An error occured while trying to leave meeting with an id of ' + _this17.id, err);
      }).finally(function () {
        _this17.state.clean();
      });
    }
    // /**
    //  *
    //  * Move this meeting to a given device
    //  * only possible if you are paired with the given device
    //  * @param {string} deviceID
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // moveToDevice(deviceID) {
    //   return new Promise((resolve) => resolve(deviceID));
    // }

    // /**
    //  *
    //  * Move this meeting back to the current client device, e.g., personal laptop.
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // moveToClient() {
    //   return new Promise((resolve) => resolve({}));
    // }

    // /**
    //  *
    //  * Update the audio options of this meeting
    //  * @param {string} status
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // updateAudio(status) {
    //   return new Promise((resolve) => resolve(status));
    // }

    // /**
    //  *
    //  * Update the video option of this meeting
    //  * @param {string} status
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // updateVideo(status) {
    //   return new Promise((resolve) => resolve(status));
    // }

    // /**
    //  *
    //  * Update screen sharing preference of this meeting
    //  * @param {string} shareType
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // updateShare(shareType) {
    //   return new Promise((resolve) => resolve(shareType));
    // }

    /**
     * start sharing content
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'share',
    value: function share() {
      var content = this.locusInfo.mediaShares.find(function (element) {
        return element.name === _constants.CONTENT;
      });
      if (content) {
        return this.meetingRequest.changeMeetingFloor({
          disposition: _constants.FLOOR_ACTION.GRANTED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: content.url,
          resourceUrl: this.resourceUrl
        });
      }
      return _promise2.default.reject(new Error('Cannot share without content.'));
    }

    /**
     * stops the screen share
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'stopShare',
    value: function stopShare() {
      var content = this.locusInfo.mediaShares.find(function (element) {
        return element.name === _constants.CONTENT;
      });
      if (content) {
        return this.meetingRequest.changeMeetingFloor({
          disposition: _constants.FLOOR_ACTION.RELEASED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: content.url,
          resourceUrl: this.resourceUrl
        });
      }
      return _promise2.default.reject(new Error('Cannot stop share without content'));
    }

    // /**
    //  *
    //  * Send this meeting to the phone system
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // sendDtmf() {
    //   return new Promise((resolve) => resolve({}));
    // }
    // /**
    //  *
    //  * Get statistics of the current meeting
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // getStats() {
    //   return new Promise((resolve) => resolve({}));
    // }

    // /**
    //  *
    //  * Lock this meeting
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // lock() {
    //   return new Promise((resolve) => resolve({}));
    // }

    // /**
    //  *
    //  * Unlock this meeting
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // unlock() {
    //   return new Promise((resolve) => resolve({}));
    // }

    // /**
    //  *
    //  * Intiate a recording of this meeting
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // startRecording() {
    //   return new Promise((resolve) => resolve({}));
    // }

    // /**
    //  *
    //  * End the recording of this meeting
    //  * @returns {Promise}
    //  * @memberof Meeting
    //  */
    // stopRecording() {
    //   return new Promise((resolve) => resolve({}));
    // }

  }]);
  return Meeting;
}(_sparkCore.StatelessSparkPlugin);

exports.default = Meeting;
//# sourceMappingURL=index.js.map
