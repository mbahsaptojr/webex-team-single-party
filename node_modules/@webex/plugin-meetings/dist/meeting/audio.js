'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _javascriptStateMachine = require('javascript-state-machine');

var _javascriptStateMachine2 = _interopRequireDefault(_javascriptStateMachine);

var _history = require('javascript-state-machine/lib/history');

var _history2 = _interopRequireDefault(_history);

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

var _util = require('../meeting/util');

var _util2 = _interopRequireDefault(_util);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var handleTransition = function handleTransition(audio) {
  if (audio.mute && audio.self) {
    return _constants.MEETING_AUDIO_STATE_MACHINE.STATES.MUTE_SELF;
  }
  if (!audio.mute && audio.self) {
    return _constants.MEETING_AUDIO_STATE_MACHINE.STATES.UNMUTE_SELF;
  }
  return null;
}; /* eslint-disable no-console */

var triggerEvent = function triggerEvent(meeting, state, result, trigger, type) {
  meeting.trigger(trigger, {
    type: type,
    status: state.state,
    muted: state.muted,
    result: result
  });
};

var doToggle = function doToggle(state, transition, audio, meeting) {
  _util2.default.remoteUpdateAudioVideo(audio, { mute: meeting.video.muted }, meeting).then(function (resolution) {
    try {
      _media2.default.setLocalTracks(audio, { mute: meeting.video.muted }, meeting.mediaProperties.localStream);
    } catch (error) {
      _util2.default.remoteUpdateAudioVideo({ mute: state.muted }, { mute: meeting.video.muted }, meeting).catch(function (remoteUpdateError) {
        console.log('audio:state#onBeforeToggle->' + transition.event + ' fired! State failed to change with transition \'' + transition.transition + '\'\'. After local audio toggle failed, resetting remote also failed, meeting audio in bad state with error: ' + remoteUpdateError + '.');
      });
      triggerEvent(meeting, state, error, _constants.EVENT_TRIGGERS.MEDIA_AUDIO_CHANGED, _constants.EVENT_TYPES.ERROR);
      console.log('audio:state#onBeforeToggle->' + transition.event + ' fired! State failed to change with transition \'' + transition.transition + '\'\'. State has been reset and toggling has been reversed.');
      return _promise2.default.reject(error);
    }
    triggerEvent(meeting, state, resolution, _constants.EVENT_TRIGGERS.MEDIA_AUDIO_CHANGED, _constants.EVENT_TYPES.LOCAL);
    console.log('audio:state#onAfterToggle->' + transition.event + ' fired! State changed from \'' + transition.from + '\' to \'' + transition.to + '\' with transition \'' + transition.transition + '\'\'.');
    return _promise2.default.resolve(resolution);
  }).catch(function (error) {
    triggerEvent(meeting, state, error, _constants.EVENT_TRIGGERS.MEDIA_AUDIO_CHANGED, _constants.EVENT_TYPES.ERROR);
    console.log('audio:state#onAfterHistoryBack->' + transition.event + ' fired! State failed to change with transition \'' + transition.transition + '\'\'. State has been reset and toggling has been reversed.');
    return _promise2.default.reject(error);
  });
};

var AudioStateMachine = {
  /**
   *
   * @param {Object} mediaDirection An object that contains whether we send audio/video/screen streams
   * @param {Meeting} meeting the meeting instance we are using for this state machine
   * @returns {StateMachine} returns a StateMachine instance
   */
  create: function create(mediaDirection, meeting) {
    if (!mediaDirection.sendAudio) {
      return null;
    }
    return new _javascriptStateMachine2.default({
      transitions: [{
        name: _constants.MEETING_AUDIO_STATE_MACHINE.TRANSITIONS.TOGGLE,
        from: '*',
        /**
         *
         * @param {Object} audio The audio options
         * @param {Boolean} audio.mute Whether to mute the meeting or not
         * @param {Boolean} audio.self Whether the was muted by the end user
         * @param {Boolean} audio.remote Whether the meeting was muted by the server
         * @returns {String} returns a new value to set the state to
         */
        to: function to(audio) {
          return handleTransition(audio) || this.state;
        }
      }],
      data: {
        muted: false,
        self: true
      },
      methods: {
        /**
         * Convenience method to return whether the call is muted or not
         * @returns {Boolen} whether the audio is muted or not
         */
        isMuted: function isMuted() {
          return this.muted;
        },


        /**
         * Convenience method to expose this.self
         * @returns {Boolen} this.self
         */
        isSelf: function isSelf() {
          return this.self;
        },


        /**
         *
         * @param {Object} audio the audio state to change
         * @returns {null}
         */
        setData: function setData(audio) {
          this.muted = audio.mute;
          this.self = audio.self;
        },


        /**
         * Method that gets fired before the toggle state change.
         * If this fails, return false will cancel the transition and the state will remain unchanged
          * @param {Object} transition the StateMachine transition object
         * @param {Object} audio Audio options
         * @returns {Object} this.data which contains {muted, self}
         */
        onBeforeToggle: function onBeforeToggle(transition, audio) {
          if (transition.from !== transition.to) {
            doToggle(this, transition, audio, meeting);
          }
          return _promise2.default.resolve(this.data);
        },


        /**
         *
         * @param {Object} transition StateMachine transition
         * @param {Object} audio audio options
         * @returns {Object} this.data which contains {muted, self}
         */
        onAfterToggle: function onAfterToggle(transition, audio) {
          this.setData(audio);
          return _promise2.default.resolve(this.data);
        },

        plugins: [new _history2.default({ max: 5 })]
      }
    });
  }
};

exports.default = AudioStateMachine;
//# sourceMappingURL=audio.js.map
