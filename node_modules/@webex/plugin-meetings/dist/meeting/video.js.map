{"version":3,"sources":["video.js"],"names":["handleTransition","video","mute","self","MEETING_VIDEO_STATE_MACHINE","STATES","MUTE_SELF","UNMUTE_SELF","triggerEvent","meeting","state","result","trigger","type","status","muted","doToggle","transition","MeetingUtil","remoteUpdateAudioVideo","audio","then","resolution","Media","setLocalTracks","mediaProperties","localStream","error","catch","remoteUpdateError","console","log","event","EVENT_TRIGGERS","MEDIA_VIDEO_CHANGED","EVENT_TYPES","ERROR","reject","LOCAL","from","to","resolve","VideoStateMachine","create","mediaDirection","sendVideo","undefined","StateMachine","transitions","name","TRANSITIONS","TOGGLE","data","methods","isMuted","isSelf","setData","onBeforeToggle","onAfterToggle","plugins","StateMachineHistory","max"],"mappings":"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","file":"video.js","sourcesContent":["/* eslint-disable no-console */\n\nimport StateMachine from 'javascript-state-machine';\nimport StateMachineHistory from 'javascript-state-machine/lib/history';\n\nimport Media from '../media';\nimport MeetingUtil from '../meeting/util';\nimport {MEETING_VIDEO_STATE_MACHINE, EVENT_TRIGGERS, EVENT_TYPES} from '../constants';\n\nconst handleTransition = (video) => {\n  if (video.mute && video.self) {\n    return MEETING_VIDEO_STATE_MACHINE.STATES.MUTE_SELF;\n  }\n  if (!video.mute && video.self) {\n    return MEETING_VIDEO_STATE_MACHINE.STATES.UNMUTE_SELF;\n  }\n\n  return null;\n};\n\nconst triggerEvent = (meeting, state, result, trigger, type) => {\n  meeting.trigger(trigger, {\n    type,\n    status: state.state,\n    muted: state.muted,\n    result\n  });\n};\n\nconst doToggle = (state, transition, video, meeting) => {\n  MeetingUtil.remoteUpdateAudioVideo({mute: meeting.audio.muted}, video, meeting)\n    .then((resolution) => {\n      try {\n        Media.setLocalTracks({mute: meeting.audio.muted}, video, meeting.mediaProperties.localStream);\n      }\n      catch (error) {\n        MeetingUtil.remoteUpdateAudioVideo({mute: meeting.audio.muted}, {mute: state.muted}, meeting).catch(\n          (remoteUpdateError) => {\n            console.log(\n              `video:state#onBeforeTogglek->${transition.event} fired! State failed to change with transition ${\n                transition.transition\n              }. After local video toggle failed, resetting remote also failed, meeting video in bad state with error: ${remoteUpdateError}.`\n            );\n          }\n        );\n        triggerEvent(meeting, state, error, EVENT_TRIGGERS.MEDIA_VIDEO_CHANGED, EVENT_TYPES.ERROR);\n        console.log(\n          `video:state#onBeforeTogglek->${transition.event} fired! State failed to change with transition '${\n            transition.transition\n          }''. State has been reset and toggling has been reversed.`\n        );\n        return Promise.reject(error);\n      }\n      triggerEvent(meeting, state, resolution, EVENT_TRIGGERS.MEDIA_VIDEO_CHANGED, EVENT_TYPES.LOCAL);\n      console.log(\n        `video:state#onAfterToggle->${transition.event} fired! State changed from '${transition.from}' to '${\n          transition.to\n        }' with transition '${transition.transition}''.`\n      );\n      return Promise.resolve(resolution);\n    })\n    .catch((error) => {\n      triggerEvent(meeting, state, error, EVENT_TRIGGERS.MEDIA_VIDEO_CHANGED, EVENT_TYPES.ERROR);\n      console.log(\n        `video:state#onAfterHistoryBack->${transition.event} fired! State failed to change with transition '${\n          transition.transition\n        }''. State has been reset and toggling has been reversed.`\n      );\n      return Promise.reject(error);\n    });\n};\n\nconst VideoStateMachine = {\n  /**\n   *\n   * @param {Object} mediaDirection object containing media direction\n   * @param {Boolean} mediaDirection.sendVideo Whether or not to send video in the meeting\n   * @param {Meeting} meeting an instance of a Meeting\n   * @returns {Statemachine} returns a state machine instance\n   */\n  create(mediaDirection, meeting) {\n    if (!mediaDirection.sendVideo) {\n      return undefined;\n    }\n    return new StateMachine({\n      transitions: [\n        {\n          name: MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,\n          from: '*',\n          /**\n           *\n           * @param {Object} video current video data for the transition {mute, self}\n           * @returns {String} a new state value for the transition\n           */\n          to(video) {\n            return handleTransition(video) || this.state;\n          }\n        }\n      ],\n      data: {\n        muted: false,\n        self: true\n      },\n      methods: {\n        /**\n         * Convenience function to tell whether we are muted or not\n         * @returns {Boolen} boolean that indicates whether the video is currently muted\n         */\n        isMuted() {\n          return this.muted;\n        },\n        /**\n         * Convenience function to tell who last muted/unmuted the video\n         * @returns {Boolen} boolean that indicates whether the video was muted by the end user or server\n         */\n        isSelf() {\n          return this.self;\n        },\n\n        /**\n         *\n         * @param {Object} video current video options to set on the state machine\n         * @param {Boolean} video.mute indicates if video is muted or not for a meeting\n         * @param {Boolean} video.self indicates whether the end user or server muted the video\n         * @returns {null}\n         */\n        setData(video) {\n          this.muted = video.mute;\n          this.self = video.self;\n        },\n\n        /**\n         * Method that gets fired before the toggle state change.\n         * If this fails, return false will cancel the transition and the state will remain unchanged\n\n         * @param {Object} transition the StateMachine transition object\n         * @param {Object} video video options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onBeforeToggle(transition, video) {\n          if (transition.from !== transition.to) {\n            doToggle(this, transition, video, meeting);\n          }\n          return Promise.resolve(this.data);\n        },\n\n        /**\n         *\n         * @param {Object} transition StateMachine transition\n         * @param {Object} video video options\n         * @returns {Object} this.data which contains {muted, self}\n         */\n        onAfterToggle(transition, video) {\n          this.setData(video);\n          return Promise.resolve(this.data);\n        },\n        plugins: [new StateMachineHistory({max: 5})]\n      }\n    });\n  }\n};\n\nexport default VideoStateMachine;\n"]}