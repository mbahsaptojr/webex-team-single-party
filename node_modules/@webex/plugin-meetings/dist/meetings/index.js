'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

require('@ciscospark/internal-plugin-mercury');

var _sparkCore = require('@ciscospark/spark-core');

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _constants = require('../constants');

var _meetingInfo = require('../meeting-info');

var _meetingInfo2 = _interopRequireDefault(_meetingInfo);

var _meeting = require('../meeting');

var _meeting2 = _interopRequireDefault(_meeting);

var _personalMeetingRoom = require('../personal-meeting-room');

var _personalMeetingRoom2 = _interopRequireDefault(_personalMeetingRoom);

var _reachability = require('../reachability');

var _reachability2 = _interopRequireDefault(_reachability);

var _request = require('../meetings/request');

var _request2 = _interopRequireDefault(_request);

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Meetings Ready Event
 * Emitted when the meetings instance on spark is ready
 * @event meetings:ready
 * @instance
 * @memberof Meetings
 */

/**
  * Meeting Removed Event
  * Emitted when a meeting was removed from the cache of meetings
  * @event meeting:removed
  * @instance
  * @type {Object}
  * @property {Meeting} meeting the removed meeting
  * @property {Object} response the server response
  * @property {String} type what type of meeting it was
  * @memberof Meetings
  */

/**
 * Maintain a cache of meetings and sync with services.
 * @class
 */
var Meetings = function (_SparkPlugin) {
  (0, _inherits3.default)(Meetings, _SparkPlugin);

  /**
   * Initializes the Meetings Plugin
   * @constructor
   * @public
   * @memberof Meetings
   */
  function Meetings() {
    var _ref;

    (0, _classCallCheck3.default)(this, Meetings);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /**
     * The MeetingInfo object to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Meetings.__proto__ || (0, _getPrototypeOf2.default)(Meetings)).call.apply(_ref, [this].concat(args)));

    _this.namespace = _constants.MEETINGS;
    _this.meetingInfo = new _meetingInfo2.default({}, { parent: _this.spark });
    /**
     * The Meetings request to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    _this.request = new _request2.default({}, { parent: _this.spark });
    /**
     * The PersonalMeetingRoom object to interact with server
     * @instance
     * @type {Object}
     * @public
     * @memberof Meetings
     */
    _this.personalMeetingRoom = new _personalMeetingRoom2.default({}, { parent: _this.spark });
    /**
     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called
     * starts as null
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    _this.reachability = null;
    _this.onReady();
    return _this;
  }

  /**
   * handle locus events and takes meeting actions with them as they come in
   * @param {Object} data a locus event
   * @param {String} data.locusUrl
   * @param {Object} data.locus
   * @param {String} data.eventType
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */


  (0, _createClass3.default)(Meetings, [{
    key: 'handleLocusEvent',
    value: function handleLocusEvent(data) {
      var meeting = null;
      meeting = _collection2.default.getByKey(_constants.LOCUS_URL, data.locusUrl);
      if (!meeting) {
        // TODO: create meeting when we get a meeting object
        // const checkForEnded = (locus) => {
        // TODO: you already ended the meeting but you got an event later
        // Mainly for 1:1 Callsor meeting
        // Happens mainly after refresh

        // 1:1 Meeting
        // 1)  You ended a call before but you got a mercury event
        // Make sure end the call and cleanup the meeting only if the mercury
        // event says so
        // 2) Maintain lastSync time in the meetings object which helps to compare
        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid

        // For space Meeting
        // Check the locus object and see who has joined

        // };

        // rather then locus object change to locus url
        this.create(data.locus, _constants.LOCUS_ID).then(function (newMeeting) {
          if (data.eventType === _constants.LOCUSEVENT.DIFFERENCE) {
            // its a delta object and we have a new meeting
            newMeeting.locusInfo.initialSetup(data.locus, meeting);
          } else {
            // Its a new meeting and have a fresh locus object
            newMeeting.locusInfo.initialSetup(data.locus);
          }
        });
      } else {
        meeting.locusInfo.parse(meeting, data);
      }
    }

    /**
     * handles locus events through mercury that are not roap
     * @param {Object} envelope
     * @param {Object} envelope.data
     * @param {String} envelope.data.eventType
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'handleLocusMercury',
    value: function handleLocusMercury(envelope) {
      var data = envelope.data;
      var eventType = data.eventType;

      if (eventType && eventType !== _constants.LOCUSEVENT.MESSAGE_ROAP) {
        this.handleLocusEvent(data);
      }
    }

    /**
     * registers for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'listenForEvents',
    value: function listenForEvents() {
      var _this2 = this;

      this.spark.internal.mercury.on(_constants.LOCUSEVENT.LOCUS_MERCURY, function (envelope) {
        _this2.handleLocusMercury(envelope);
      });
      this.spark.internal.mercury.on(_constants.ROAP.ROAP_MERCURY, function (envelope) {
        _util2.default.handleRoapMercury(envelope);
      });
    }

    /**
     * listens for internal events and triggers correct top level function
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'listenInternal',
    value: function listenInternal() {
      var _this3 = this;

      _events2.default.on(_constants.EVENTS.DESTROY_MEETING_DECLINE_1_1, function (payload) {
        if (payload) {
          _this3.destroy(payload.meeting, payload.response, payload.type);
        }
      });
    }

    /**
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'onReady',
    value: function onReady() {
      var _this4 = this;

      this.spark.once(_constants.READY, function () {
        if (_this4.spark.canAuthorize) {
          _this4.listenForEvents();
          _this4.listenInternal();
          _this4.trigger(_constants.EVENT_TRIGGERS.MEETINGS_READY);
        }
      });
    }

    /**
     * initializes the reachability instance for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'setReachability',
    value: function setReachability() {
      this.reachability = new _reachability2.default({}, { parent: this.spark });
    }

    /**
     * gets the reachability instance for Meetings
     * @returns {Reachability}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getReachability',
    value: function getReachability() {
      return this.reachability;
    }

    /**
     * initializes and starts gathering reachability for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'startReachability',
    value: function startReachability() {
      if (!this.reachability) {
        this.setReachability();
      }
      this.getReachability().gatherReachability();
    }

    /**
     * gets the personal meeting room instance, for saved PMR values for this user
     * @returns {PersonalMeetingRoom}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getPersonalMeetingRoom',
    value: function getPersonalMeetingRoom() {
      return this.personalMeetingRoom;
    }

    /**
     * @param {Meeting} meeting
     * @param {Object} response
     * @param {String} type
     * @returns {Object}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'destroy',
    value: function destroy(meeting, response, type) {
      if (!meeting || !meeting.id) {
        throw new Error('Cannot remove a meeting without an id from the MeetingCollection.');
      }
      _collection2.default.remove(meeting.id);
      this.trigger(_constants.EVENT_TRIGGERS.MEETING_REMOVED, {
        meeting: meeting,
        response: response,
        type: type
      });
      return response;
    }

    /**
     * Create a meeting.
     * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}
     * @param {string} type - the optional specified type, such as locusId
     * @returns {Promise} A new Meeting.
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'create',
    value: function create(destination) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return this.createMeeting(destination, type);
    }

    /**
     * @param {String} destination see create()
     * @param {String} type see create()
     * @returns {Promise} a new meeting instance complete with meeting info and destination
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'createMeeting',
    value: function createMeeting(destination) {
      var _this5 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var meeting = new _meeting2.default({
        userId: this.spark.internal.device.userId,
        deviceUrl: this.spark.internal.device.url,
        roapSeq: 0,
        locus: type === _constants.LOCUS_ID ? destination : null // pass the locus object if present
      }, {
        parent: this.spark
      });

      _collection2.default.set(meeting);

      return this.meetingInfo.fetchMeetingInfo(_util2.default.extractDestination(destination, type), type).then(function (info) {
        meeting.parseMeetingInfo(info);
        meeting.meetingInfo = info;
      }).catch(function (err) {
        console.error(err);
      }).then(function () {
        if (!meeting.sipUri) {
          meeting.setSipUri(destination);
        }
        // TODO: check if we have to move this to parser
        var meetingAddedType = _util2.default.getMeetingAddedType(type);

        // We typically shouldn't need to trigger both and event and return a promise.
        // Is this a special case? We want to make the public API usage as simple as possible.
        _this5.trigger(_constants.EVENT_TRIGGERS.MEETING_ADDED, {
          meeting: meeting,
          type: meetingAddedType
        });

        return meeting;
      });

      // Create the meeting calling the necessary service endpoints.

      // Internally, there are many more destinations:
      //
      // - locusID
      // - meetingURL
      // - globalMeetingID, e.g, *00*meetingID
      // - meetingID
      // - meetingURL
      // - PSTN
      // - phone number
      //
      // Our job is to determine the appropriate one
      // and its corresponding service so that developers
      // need only sipURL or spaceID to get a meeting
      // and its ID, but have the option to use createWithType()
      // and specify those types to get meetingInfo
    }

    /**
     * get a specifc meeting given it's type matched to the value, i.e., locus url
     * @param {String} type
     * @param {Object} value
     * @returns {Meeting}
     * @public
     * @static
     * @memberof Meetings
     */

  }, {
    key: 'syncMeetings',


    /**
     * syncs all the meeting from server
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */
    value: function syncMeetings() {
      var _this6 = this;

      return this.request.getActiveMeetings().then(function (locus) {
        if (locus.loci && locus.loci.length > 0) {
          locus.loci.forEach(function (locus) {
            var meeting = _collection2.default.getByKey(_constants.LOCUS_URL, locus.url);
            if (meeting) {
              meeting.locusInfo.onFullLocus(locus);
            } else {
              _this6.create(locus, _constants.LOCUS_ID).then(function (meeting) {
                meeting.locusInfo.initialSetup(locus);
              });
            }
          });
        }
      });
    }

    /**
     * Get all active meetings.
     * @returns {Object} All active meetings.
     * @public
     * @static
     * @memberof Meetings
     */

  }], [{
    key: 'getMeetingByType',
    value: function getMeetingByType(type, value) {
      return _collection2.default.getByKey(type, value);
    }

    /**
     * Get all meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All active and scheduled meetings.
     * @public
     * @static
     * @memberof Meetings
     */

  }, {
    key: 'getAllMeetings',
    value: function getAllMeetings() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Options may include other parameters to filter this collection
      // of meetings.
      return _collection2.default.getAll(options);
    }
  }, {
    key: 'getActiveMeetings',
    value: function getActiveMeetings() {
      return _collection2.default.getAll({ active: true });
    }
  }]);
  return Meetings;
}(_sparkCore.SparkPlugin); /*!
                            * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
                            */


exports.default = Meetings;
//# sourceMappingURL=index.js.map
