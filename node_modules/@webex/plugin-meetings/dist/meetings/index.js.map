{"version":3,"sources":["index.js"],"names":["Meetings","args","namespace","MEETINGS","meetingInfo","MeetingInfo","parent","spark","request","Request","personalMeetingRoom","PersonalMeetingRoom","reachability","onReady","data","meeting","MeetingCollection","getByKey","LOCUS_URL","locusUrl","create","locus","LOCUS_ID","then","newMeeting","eventType","LOCUSEVENT","DIFFERENCE","locusInfo","initialSetup","parse","envelope","MESSAGE_ROAP","handleLocusEvent","internal","mercury","on","LOCUS_MERCURY","handleLocusMercury","ROAP","ROAP_MERCURY","MeetingsUtil","handleRoapMercury","Events","EVENTS","DESTROY_MEETING_DECLINE_1_1","payload","destroy","response","type","once","READY","canAuthorize","listenForEvents","listenInternal","trigger","EVENT_TRIGGERS","MEETINGS_READY","Reachability","setReachability","getReachability","gatherReachability","id","Error","remove","MEETING_REMOVED","destination","createMeeting","Meeting","userId","device","deviceUrl","url","roapSeq","set","fetchMeetingInfo","extractDestination","info","parseMeetingInfo","catch","err","console","error","sipUri","setSipUri","meetingAddedType","getMeetingAddedType","MEETING_ADDED","getActiveMeetings","loci","length","forEach","onFullLocus","value","options","getAll","active","SparkPlugin"],"mappings":"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","file":"index.js","sourcesContent":["/*!\n * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.\n */\nimport '@ciscospark/internal-plugin-mercury';\n\nimport {SparkPlugin} from '@ciscospark/spark-core';\n\nimport Events from '../events';\nimport {\n  MEETINGS,\n  EVENTS,\n  EVENT_TRIGGERS,\n  READY,\n  LOCUSEVENT,\n  LOCUS_URL,\n  ROAP,\n  LOCUS_ID\n} from '../constants';\nimport MeetingInfo from '../meeting-info';\nimport Meeting from '../meeting';\nimport PersonalMeetingRoom from '../personal-meeting-room';\nimport Reachability from '../reachability';\nimport Request from '../meetings/request';\n\nimport MeetingCollection from './collection';\nimport MeetingsUtil from './util';\n\n/**\n * Meetings Ready Event\n * Emitted when the meetings instance on spark is ready\n * @event meetings:ready\n * @instance\n * @memberof Meetings\n */\n\n/**\n  * Meeting Removed Event\n  * Emitted when a meeting was removed from the cache of meetings\n  * @event meeting:removed\n  * @instance\n  * @type {Object}\n  * @property {Meeting} meeting the removed meeting\n  * @property {Object} response the server response\n  * @property {String} type what type of meeting it was\n  * @memberof Meetings\n  */\n\n/**\n * Maintain a cache of meetings and sync with services.\n * @class\n */\nexport default class Meetings extends SparkPlugin {\n  namespace = MEETINGS;\n\n  /**\n   * Initializes the Meetings Plugin\n   * @constructor\n   * @public\n   * @memberof Meetings\n   */\n  constructor(...args) {\n    super(...args);\n    /**\n     * The MeetingInfo object to interact with server\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n    this.meetingInfo = new MeetingInfo({}, {parent: this.spark});\n    /**\n     * The Meetings request to interact with server\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n    this.request = new Request({}, {parent: this.spark});\n    /**\n     * The PersonalMeetingRoom object to interact with server\n     * @instance\n     * @type {Object}\n     * @public\n     * @memberof Meetings\n     */\n    this.personalMeetingRoom = new PersonalMeetingRoom({}, {parent: this.spark});\n    /**\n     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called\n     * starts as null\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof Meetings\n     */\n    this.reachability = null;\n    this.onReady();\n  }\n\n  /**\n   * handle locus events and takes meeting actions with them as they come in\n   * @param {Object} data a locus event\n   * @param {String} data.locusUrl\n   * @param {Object} data.locus\n   * @param {String} data.eventType\n   * @returns {undefined}\n   * @private\n   * @memberof Meetings\n   */\n  handleLocusEvent(data) {\n    let meeting = null;\n    meeting = MeetingCollection.getByKey(LOCUS_URL, data.locusUrl);\n    if (!meeting) {\n      // TODO: create meeting when we get a meeting object\n      // const checkForEnded = (locus) => {\n      // TODO: you already ended the meeting but you got an event later\n      // Mainly for 1:1 Callsor meeting\n      // Happens mainly after refresh\n\n      // 1:1 Meeting\n      // 1)  You ended a call before but you got a mercury event\n      // Make sure end the call and cleanup the meeting only if the mercury\n      // event says so\n      // 2) Maintain lastSync time in the meetings object which helps to compare\n      // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid\n\n      // For space Meeting\n      // Check the locus object and see who has joined\n\n      // };\n\n      // rather then locus object change to locus url\n      this.create(data.locus, LOCUS_ID).then((newMeeting) => {\n        if (data.eventType === LOCUSEVENT.DIFFERENCE) {\n          // its a delta object and we have a new meeting\n          newMeeting.locusInfo.initialSetup(data.locus, meeting);\n        }\n        else {\n          // Its a new meeting and have a fresh locus object\n          newMeeting.locusInfo.initialSetup(data.locus);\n        }\n      });\n    }\n    else {\n      meeting.locusInfo.parse(meeting, data);\n    }\n  }\n\n  /**\n   * handles locus events through mercury that are not roap\n   * @param {Object} envelope\n   * @param {Object} envelope.data\n   * @param {String} envelope.data.eventType\n   * @returns {undefined}\n   * @private\n   * @memberof Meetings\n   */\n  handleLocusMercury(envelope) {\n    const {data} = envelope;\n    const {eventType} = data;\n    if (eventType && eventType !== LOCUSEVENT.MESSAGE_ROAP) {\n      this.handleLocusEvent(data);\n    }\n  }\n\n  /**\n   * registers for locus and roap mercury events\n   * @returns {undefined}\n   * @private\n   * @memberof Meetings\n   */\n  listenForEvents() {\n    this.spark.internal.mercury.on(LOCUSEVENT.LOCUS_MERCURY, (envelope) => {\n      this.handleLocusMercury(envelope);\n    });\n    this.spark.internal.mercury.on(ROAP.ROAP_MERCURY, (envelope) => {\n      MeetingsUtil.handleRoapMercury(envelope);\n    });\n  }\n\n  /**\n   * listens for internal events and triggers correct top level function\n   * @returns {undefined}\n   * @private\n   * @memberof Meetings\n   */\n  listenInternal() {\n    Events.on(EVENTS.DESTROY_MEETING_DECLINE_1_1, (payload) => {\n      if (payload) {\n        this.destroy(payload.meeting, payload.response, payload.type);\n      }\n    });\n  }\n\n  /**\n   * @returns {undefined}\n   * @private\n   * @memberof Meetings\n   */\n  onReady() {\n    this.spark.once(READY, () => {\n      if (this.spark.canAuthorize) {\n        this.listenForEvents();\n        this.listenInternal();\n        this.trigger(EVENT_TRIGGERS.MEETINGS_READY);\n      }\n    });\n  }\n\n  /**\n   * initializes the reachability instance for Meetings\n   * @returns {undefined}\n   * @public\n   * @memberof Meetings\n   */\n  setReachability() {\n    this.reachability = new Reachability({}, {parent: this.spark});\n  }\n\n  /**\n   * gets the reachability instance for Meetings\n   * @returns {Reachability}\n   * @public\n   * @memberof Meetings\n   */\n  getReachability() {\n    return this.reachability;\n  }\n\n  /**\n   * initializes and starts gathering reachability for Meetings\n   * @returns {undefined}\n   * @public\n   * @memberof Meetings\n   */\n  startReachability() {\n    if (!this.reachability) {\n      this.setReachability();\n    }\n    this.getReachability().gatherReachability();\n  }\n\n  /**\n   * gets the personal meeting room instance, for saved PMR values for this user\n   * @returns {PersonalMeetingRoom}\n   * @public\n   * @memberof Meetings\n   */\n  getPersonalMeetingRoom() {\n    return this.personalMeetingRoom;\n  }\n\n  /**\n   * @param {Meeting} meeting\n   * @param {Object} response\n   * @param {String} type\n   * @returns {Object}\n   * @private\n   * @memberof Meetings\n   */\n  destroy(meeting, response, type) {\n    if (!meeting || !meeting.id) {\n      throw new Error('Cannot remove a meeting without an id from the MeetingCollection.');\n    }\n    MeetingCollection.remove(meeting.id);\n    this.trigger(EVENT_TRIGGERS.MEETING_REMOVED, {\n      meeting,\n      response,\n      type\n    });\n    return response;\n  }\n\n  /**\n   * Create a meeting.\n   * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}\n   * @param {string} type - the optional specified type, such as locusId\n   * @returns {Promise} A new Meeting.\n   * @public\n   * @memberof Meetings\n   */\n  create(destination, type = null) {\n    return this.createMeeting(destination, type);\n  }\n\n  /**\n   * @param {String} destination see create()\n   * @param {String} type see create()\n   * @returns {Promise} a new meeting instance complete with meeting info and destination\n   * @private\n   * @memberof Meetings\n   */\n  createMeeting(destination, type = null) {\n    const meeting = new Meeting(\n      {\n        userId: this.spark.internal.device.userId,\n        deviceUrl: this.spark.internal.device.url,\n        roapSeq: 0,\n        locus: type === LOCUS_ID ? destination : null // pass the locus object if present\n      },\n      {\n        parent: this.spark\n      }\n    );\n\n    MeetingCollection.set(meeting);\n\n    return this.meetingInfo\n      .fetchMeetingInfo(MeetingsUtil.extractDestination(destination, type), type)\n      .then((info) => {\n        meeting.parseMeetingInfo(info);\n        meeting.meetingInfo = info;\n      })\n      .catch((err) => {\n        console.error(err);\n      })\n      .then(() => {\n        if (!meeting.sipUri) {\n          meeting.setSipUri(destination);\n        }\n        // TODO: check if we have to move this to parser\n        const meetingAddedType = MeetingsUtil.getMeetingAddedType(type);\n\n        // We typically shouldn't need to trigger both and event and return a promise.\n        // Is this a special case? We want to make the public API usage as simple as possible.\n        this.trigger(EVENT_TRIGGERS.MEETING_ADDED, {\n          meeting,\n          type: meetingAddedType\n        });\n\n        return meeting;\n      });\n\n    // Create the meeting calling the necessary service endpoints.\n\n    // Internally, there are many more destinations:\n    //\n    // - locusID\n    // - meetingURL\n    // - globalMeetingID, e.g, *00*meetingID\n    // - meetingID\n    // - meetingURL\n    // - PSTN\n    // - phone number\n    //\n    // Our job is to determine the appropriate one\n    // and its corresponding service so that developers\n    // need only sipURL or spaceID to get a meeting\n    // and its ID, but have the option to use createWithType()\n    // and specify those types to get meetingInfo\n  }\n\n  /**\n   * get a specifc meeting given it's type matched to the value, i.e., locus url\n   * @param {String} type\n   * @param {Object} value\n   * @returns {Meeting}\n   * @public\n   * @static\n   * @memberof Meetings\n   */\n  static getMeetingByType(type, value) {\n    return MeetingCollection.getByKey(type, value);\n  }\n\n  /**\n   * Get all meetings.\n   * @param {object} options\n   * @param {object} options.startDate - get meetings after this start date\n   * @param {object} options.endDate - get meetings before this end date\n   * @returns {Object} All active and scheduled meetings.\n   * @public\n   * @static\n   * @memberof Meetings\n   */\n  static getAllMeetings(options = {}) {\n    // Options may include other parameters to filter this collection\n    // of meetings.\n    return MeetingCollection.getAll(options);\n  }\n\n  /**\n   * syncs all the meeting from server\n   * @returns {undefined}\n   * @public\n   * @memberof Meetings\n   */\n  syncMeetings() {\n    return this.request.getActiveMeetings().then((locus) => {\n      if (locus.loci && locus.loci.length > 0) {\n        locus.loci.forEach((locus) => {\n          const meeting = MeetingCollection.getByKey(LOCUS_URL, locus.url);\n          if (meeting) {\n            meeting.locusInfo.onFullLocus(locus);\n          }\n          else {\n            this.create(locus, LOCUS_ID)\n              .then((meeting) => {\n                meeting.locusInfo.initialSetup(locus);\n              });\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Get all active meetings.\n   * @returns {Object} All active meetings.\n   * @public\n   * @static\n   * @memberof Meetings\n   */\n  static getActiveMeetings() {\n    return MeetingCollection.getAll({active: true});\n  }\n}\n"]}