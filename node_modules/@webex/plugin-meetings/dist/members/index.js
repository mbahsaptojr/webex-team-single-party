'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _sparkCore = require('@ciscospark/spark-core');

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _constants = require('../constants');

var _member = require('../member');

var _member2 = _interopRequireDefault(_member);

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _request = require('./request');

var _request2 = _interopRequireDefault(_request);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class Members
 */
var Members = function (_StatelessSparkPlugin) {
  (0, _inherits3.default)(Members, _StatelessSparkPlugin);

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Members
   */
  function Members(attrs, options) {
    (0, _classCallCheck3.default)(this, Members);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Members.__proto__ || (0, _getPrototypeOf2.default)(Members)).call(this, {}, options));

    _this.namespace = _constants.MEETINGS;

    _this.membersRequest = new _request2.default({}, options);
    _this.membersCollection = new _collection2.default();
    _this.locusUrl = null;
    _this.hostId = null;
    // locus has a self object, sent individually to the client
    // i.e., each person in the call gets their own self object from locus
    // we need to maintain that self object, because we also get information about all the participants
    // and differentiate those participants from self
    // the self id shouldnt ever change, but it does have properties in that will change
    // and we use values in locus-info, such as to determine if i am admitted to the meeting or not as guest
    _this.selfId = null;
    _this.mediaShareContentId = null;
    _this.setUpLocusInfoListeners();
    return _this;
  }

  /**
   * set up all the listeners used for locus info
   * @returns {undefined}
   * @memberof Members
   */


  (0, _createClass3.default)(Members, [{
    key: 'setUpLocusInfoListeners',
    value: function setUpLocusInfoListeners() {
      this.setUpLocusUrlListener();
      this.setUpLocusHostListener();
      this.setUpLocusSelfListener();
      this.setUpLocusParticipantsListener();
      this.setUpLocusMediaSharesListener();
    }

    /**
     * set up the locus info self listener
     * update self value for members and updates the member
     * notifies consumer with members:self:update {activeSelfId endedSelfId}
     * @returns {undefined}
     * @event {members:self:update}
     * @memberof Members
     */

  }, {
    key: 'setUpLocusSelfListener',
    value: function setUpLocusSelfListener() {
      var _this2 = this;

      _events2.default.on(_constants.EVENTS.LOCUS_INFO_UPDATE_SELF, function (payload) {
        var newSelfId = null;
        var oldSelfId = null;
        if (payload) {
          if (payload.newSelf) {
            newSelfId = payload.newSelf.id;
          }
          if (payload.oldSelf) {
            oldSelfId = payload.oldSelf.id;
          }
        }
        if (newSelfId) {
          var theSelf = _this2.membersCollection.get(newSelfId);
          if (theSelf) {
            theSelf.setIsSelf(true);
          }
        }
        if (oldSelfId) {
          var notSelf = _this2.membersCollection.get(oldSelfId);
          if (notSelf) {
            notSelf.setIsSelf(false);
          }
        }
        _this2.selfId = newSelfId;
        _this2.trigger(_constants.EVENT_TRIGGERS.MEMBERS_SELF_UPDATE, {
          activeSelfId: newSelfId,
          endedSelfId: oldSelfId
        });
      });
    }

    /**
     * set up the locus info host listener
     * update host value for members and updates the member
     * notifies consumer with members:host:update: {activeHostId, endedHostId}
     * @returns {undefined}
     * @event {members:host:update}
     * @memberof Members
     */

  }, {
    key: 'setUpLocusHostListener',
    value: function setUpLocusHostListener() {
      var _this3 = this;

      _events2.default.on(_constants.EVENTS.LOCUS_INFO_UPDATE_HOST, function (payload) {
        var newHostId = null;
        var oldHostId = null;
        if (payload) {
          if (payload.newHost) {
            newHostId = payload.newHost.id;
          }
          if (payload.oldHost) {
            oldHostId = payload.oldHost.id;
          }
        }
        if (newHostId) {
          var theHost = _this3.membersCollection.get(newHostId);
          if (theHost) {
            theHost.setIsHost(true);
          }
        }
        if (oldHostId) {
          var notHost = _this3.membersCollection.get(oldHostId);
          if (notHost) {
            notHost.setIsHost(false);
          }
        }
        _this3.hostId = newHostId;
        _this3.trigger(_constants.EVENT_TRIGGERS.MEMBERS_HOST_UPDATE, {
          activeHostId: newHostId,
          endedHostId: oldHostId
        });
      });
    }

    /**
     * set up the locus info participants update listener
     * update members collection value for members
     * notifies consumer with members:update
     * @returns {undefined}
     * @event {members:update}
     * @memberof Members
     */

  }, {
    key: 'setUpLocusParticipantsListener',
    value: function setUpLocusParticipantsListener() {
      var _this4 = this;

      _events2.default.on(_constants.EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, function (payload) {
        _this4.handleParticipantsPayload(payload);
      });
    }

    /**
     * when new participant updates come in, both delta and full participants, update them in members collection
     * delta object in the event will have {updated, added} and full will be the full membersCollection
     * @param {Object} payload
     * @event members:update {delta, full}
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: 'handleParticipantsPayload',
    value: function handleParticipantsPayload(payload) {
      if (payload) {
        var delta = this.handleLocusInfoUpdatedParticipants(payload);
        var full = this.handleMembersUpdate(delta); // SDK should propagate the full list for both delta and non delta updates
        this.trigger(_constants.EVENT_TRIGGERS.MEMBERS_UPDATE, { delta: delta, full: full });
      }
    }

    /**
     * sets values in the members collection for updated and added properties from delta
     * @param {Object} membersUpdate {updated: [], added: []}
     * @returns {Object} membersCollection
     * @memberof Members
     */

  }, {
    key: 'handleMembersUpdate',
    value: function handleMembersUpdate(membersUpdate) {
      if (membersUpdate) {
        if (membersUpdate.updated) {
          this.constructMembers(membersUpdate.updated);
        }
        if (membersUpdate.added) {
          this.constructMembers(membersUpdate.added);
        }
      }
      return this.membersCollection.getAll();
    }

    /**
     * set members to the member collection from each updated/added lists as passed in
     * @param {Array} list
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: 'constructMembers',
    value: function constructMembers(list) {
      var _this5 = this;

      list.forEach(function (member) {
        _this5.membersCollection.set(member.id, member);
      });
    }

    /**
     * set up the locus info media shares listener
     * update content sharing id value for members, and updates the member
     * notifies consumer with members:content:update {activeContentSharingId, endedContentSharingId}
     * @returns {undefined}
     * @event {members:content:update}
     * @memberof Members
     */

  }, {
    key: 'setUpLocusMediaSharesListener',
    value: function setUpLocusMediaSharesListener() {
      var _this6 = this;

      _events2.default.on(_constants.EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, function (payload) {
        var currentContent = payload.current;
        var whoSharing = null;
        var whoStopped = null;
        if (currentContent && currentContent.contentId) {
          if (currentContent.disposition === _constants.FLOOR_ACTION.GRANTED) {
            whoSharing = currentContent.contentId;
          } else if (currentContent.disposition === _constants.FLOOR_ACTION.RELEASED) {
            whoStopped = currentContent.contentId;
          }
        }
        if (whoSharing) {
          var shareMember = _this6.membersCollection.get(whoSharing);
          if (shareMember) {
            shareMember.setIsContentSharing(true);
          }
        }
        if (whoStopped) {
          var stopMember = _this6.membersCollection.get(whoStopped);
          if (stopMember) {
            stopMember.setIsContentSharing(false);
          }
        }
        _this6.mediaShareContentId = whoSharing;
        _this6.trigger(_constants.EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE, {
          activeContentSharingId: whoSharing,
          endedContentSharingId: whoStopped
        });
      });
    }

    /**
     * set up the locus info self listener
     * update locus_url value for members
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: 'setUpLocusUrlListener',
    value: function setUpLocusUrlListener() {
      var _this7 = this;

      _events2.default.on(_constants.EVENTS.LOCUS_INFO_UPDATE_URL, function (payload) {
        if (payload) {
          _this7.setLocusUrl(null, payload);
        }
      });
    }

    /**
     * @param {Object} payload
     * @returns {Object}
     * @memberof Members
     */

  }, {
    key: 'handleLocusInfoUpdatedParticipants',
    value: function handleLocusInfoUpdatedParticipants(payload) {
      this.hostId = payload.hostId || this.hostId;
      this.selfId = payload.selfId || this.selfId;
      if (!payload.participants) {
        throw new Error('Members update could not occur, participants payload was not present.');
      }
      var memberUpdate = this.update(payload.participants);
      return memberUpdate;
    }

    /**
     * update the locus Url
     * @param {Object} locus
     * @param {String} locusUrl optional, takes precedence
     * @throws {Error}
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: 'setLocusUrl',
    value: function setLocusUrl(locus) {
      var locusUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (locusUrl) {
        this.locusUrl = locusUrl;
      } else if (locus && (locus.locusUrl || locus.url)) {
        this.locusUrl = locus.locusUrl || locus.url;
      } else {
        throw new Error('Setting locusUrl for the Members module should be done with a locus object or locusUrl');
      }
    }

    /**
     * update the locus Url
     * @param {Object} locus
     * @param {String} hostId optional, takes precedence
     * @throws {Error}
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: 'setHostId',
    value: function setHostId(locus) {
      var hostId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (hostId) {
        this.hostId = hostId;
      } else if (locus) {
        this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;
      } else {
        throw new Error('Setting hostid for the Members module should be done with a locus object or hostId');
      }
    }

    /**
     * update the locus Url
     * @param {Object} locus
     * @param {String} selfId optional, takes precedence
     * @throws {Error}
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: 'setSelfId',
    value: function setSelfId(locus) {
      var selfId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (selfId) {
        this.selfId = selfId;
      } else if (locus) {
        this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;
      } else {
        throw new Error('Setting selfid for the Members module should be done with a locus object or selfId');
      }
    }

    /**
     * update the locus Url
     * @param {Object} locus
     * @param {String} contentId optional, takes precedence
     * @throws {Error}
     * @returns {undefined}
     * @memberof Members
     */

  }, {
    key: 'setMediaShareContentId',
    value: function setMediaShareContentId(locus, contentId) {
      if (contentId) {
        this.mediaShareContentId = contentId;
      } else if (locus) {
        this.mediaShareContentId = locus && locus.mediaShares && locus.mediaShares.length && locus.mediaShares[0] && locus.mediaShares[0].name === _constants.CONTENT && locus.mediaShares[0].floor && locus.mediaShares[0].floor.beneficiary ? locus.mediaShares[0].floor.beneficiary.id : null;
      } else {
        throw new Error('Setting hostid for the Members module should be done with a locus object or hostId');
      }
    }

    /**
     * find all the updates, and added members
     * removed/left members will end up in updates
     * each array contains only members
     * @param {Array} participants the locus participants
     * @returns {Object} {added: {Array}, updated: {Array}}
     * @memberof Members
     */

  }, {
    key: 'update',
    value: function update(participants) {
      var _this8 = this;

      var membersUpdate = { added: [], updated: [] };
      if (participants) {
        participants.forEach(function (participant) {
          if (participant.hideInRoster) {
            return;
          }
          var existing = _this8.membersCollection.get(participant.id);
          if (existing) {
            // TODO: compare existing member to new participant coming in properties and determine if updated (this helps for non delta events)
            // on client re renders, but we will have to determine what values to compare to determine difference, premature optimization
            membersUpdate.updated.push(new _member2.default(participant, { selfId: _this8.selfId, hostId: _this8.hostId, contentSharingId: _this8.mediaShareContentId }));
          } else {
            membersUpdate.added.push(new _member2.default(participant, { selfId: _this8.selfId, hostId: _this8.hostId, contentSharingId: _this8.mediaShareContentId }));
          }
        });
      }
      return membersUpdate;
    }

    /**
     * adds a guest Member to the associated meeting
     * @param {String} invitee
     * @param {Boolean} alertIfActive optional parameter
     * @returns {Promise}
     * @memberof Members
     */

  }, {
    key: 'addMember',
    value: function addMember(invitee, alertIfActive) {
      if (!(!invitee || !invitee.emailAddress || !invitee.email || !this.locusUrl)) {
        return _promise2.default.reject(new Error('invitee must be passed and the associated locus url for this meeting object must be defined.'));
      }
      var options = _util2.default.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);
      return this.membersRequest.addMember(options).then(function (res) {
        return res;
      }).catch(function (error) {
        return error;
      });
    }

    /**
     * admits waiting members (invited guests to meeting)
     * @param {Array} memberIds
     * @returns {Promise}
     * @memberof Members
     */

  }, {
    key: 'admitMembers',
    value: function admitMembers(memberIds) {
      if ((0, _isEmpty3.default)(memberIds)) {
        return _promise2.default.reject(new Error('No member ids provided to admit.'));
      }
      var options = _util2.default.generateAdmitMemberOptions(memberIds, this.locusUrl);
      return this.membersRequest.admitMember(options).then(function (res) {
        return res;
      }).catch(function (error) {
        return error;
      });
    }
  }]);
  return Members;
}(_sparkCore.StatelessSparkPlugin); /*!
                                     * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
                                     */


exports.default = Members;
//# sourceMappingURL=index.js.map
