{"version":3,"sources":["selfUtils.js"],"names":["selfUtils","parse","self","deviceId","muted","getMuted","guest","moderator","mediaStatus","getStatus","status","state","joinedWith","devices","some","device","Url","SELF","OTHER","creator","isCreator","id","getId","getSelves","oldSelf","newSelf","previous","current","updates","isUnadmittedGuest","isAdmittedGuest","person","controls","audio","audioStatus","video","videoStatus","slides","videoSlidesStatus","isLocusGuestUnadmitted","check","IDLE","isLocusGuestAdmitted","JOINED","TypeError","changedSelf","getSipUrl","participants","info","partner","find","participant","identity","length","type","USER","removed","ONE_ON_ONE","sipUri","sipUrl","emailAddress","email"],"mappings":"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","file":"selfUtils.js","sourcesContent":["\nimport {IDLE, JOINED, SELF, OTHER, USER, ONE_ON_ONE} from '../constants';\n\nconst selfUtils = {};\n\n/**\n * parses the relevant values for self: muted, guest, moderator, mediaStatus, state, joinedWith, creator, id\n * @param {Object} self\n * @param {String} deviceId\n * @returns {undefined}\n */\nselfUtils.parse = (self, deviceId) => {\n  if (self) {\n    return {\n      muted: selfUtils.getMuted(self),\n      guest: self.guest,\n      moderator: self.moderator,\n      mediaStatus: selfUtils.getStatus(self.status),\n      state: self.state,\n      // TODO: give a proper name . With same device as login or different login`\n      // Some times we might have joined with both mobile and web\n      joinedWith: self.devices.some((device) => deviceId === device.Url) ? SELF : OTHER,\n      creator: self.isCreator, // check if its used,\n      id: selfUtils.getId(self)\n    };\n  }\n  return null;\n};\n\nselfUtils.getSelves = (oldSelf, newSelf, deviceId) => {\n  const previous = oldSelf && selfUtils.parse(oldSelf, deviceId);\n  const current = newSelf && selfUtils.parse(newSelf, deviceId);\n  return {\n    previous,\n    current,\n    updates: {\n      isUnadmittedGuest: selfUtils.isUnadmittedGuest(current),\n      isAdmittedGuest: selfUtils.isAdmittedGuest(previous, current)\n    }\n  };\n};\n\n/**\n * get the id from the self object\n * @param {Object} self\n * @returns {String}\n */\nselfUtils.getId = (self) => {\n  if (!self || !self.person) {\n    return null;\n  }\n  return self.person.id;\n};\n\n/**\n * get the muted property from the self object\n * @param {Object} self\n * @returns {Boolean}\n */\nselfUtils.getMuted = (self) => {\n  if (!self || !self.controls || !self.controls.audio) {\n    return null;\n  }\n  return self.controls.audio.muted;\n};\n\nselfUtils.getStatus = (status) => ({\n  audio: status.audioStatus,\n  video: status.videoStatus,\n  slides: status.videoSlidesStatus\n});\n\n/**\n * @param {Object} check\n * @returns {Boolean}\n */\nselfUtils.isLocusGuestUnadmitted = (check) => check && check.guest && check.state === IDLE;\n\n/**\n * @param {Object} check\n * @returns {Boolean}\n */\nselfUtils.isLocusGuestAdmitted = (check) => check && check.guest && check.state === JOINED;\n\n/**\n * @param {Object} self\n * @returns {Boolean}\n * @throws {Error} when self is undefined\n */\nselfUtils.isUnadmittedGuest = (self) => {\n  if (!self) {\n    throw new TypeError('self must be defined to determine if self is unadmitted as guest.');\n  }\n  return selfUtils.isLocusGuestUnadmitted(self);\n};\n\n/**\n * @param {Object} oldSelf\n * @param {Object} changedSelf\n * @returns {Boolean}\n * @throws {Error} if changed self was undefined\n */\nselfUtils.isAdmittedGuest = (oldSelf, changedSelf) => {\n  if (!oldSelf) {\n    // if there was no previous locus, it couldn't have been admitted yet\n    return false;\n  }\n  if (!changedSelf) {\n    throw new TypeError('New self must be defined to determine if self transitioned to admitted as guest.');\n  }\n  return selfUtils.isLocusGuestUnadmitted(oldSelf) && selfUtils.isLocusGuestAdmitted(changedSelf);\n};\n\n/**\n * extract the sipUrl from the partner\n * @param {Object} self\n * @param {Array} participants\n * @param {Object} info\n * @returns {Object}\n */\nselfUtils.getSipUrl = (self, participants, info) => {\n  const partner = participants.find((participant) =>\n    (self && participant.identity !== self.identity)\n    && (participants.length <= 2 || (participant.type === USER && !participant.removed)));\n\n  // For webex meeting the sipUrl gets updated in info parser\n  if (partner && info.type === ONE_ON_ONE) {\n    return {sipUri: partner.person.sipUrl || partner.person.emailAddress || partner.person.email};\n  }\n  return {sipUri: info.sipUri};\n};\n\n\nexport default selfUtils;\n"]}