'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _constants = require('../constants');

var _infoUtils = require('../locus-info/infoUtils');

var _infoUtils2 = _interopRequireDefault(_infoUtils);

var _selfUtils = require('../locus-info/selfUtils');

var _selfUtils2 = _interopRequireDefault(_selfUtils);

var _hostUtils = require('../locus-info/hostUtils');

var _hostUtils2 = _interopRequireDefault(_hostUtils);

var _mediaSharesUtils = require('../locus-info/mediaSharesUtils');

var _mediaSharesUtils2 = _interopRequireDefault(_mediaSharesUtils);

var _parser = require('../locus-info/parser');

var _parser2 = _interopRequireDefault(_parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @export
 * @class LocusInfo
 */
var LocusInfo = function () {
  function LocusInfo(callback) {
    var locus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var spark = arguments[2];
    (0, _classCallCheck3.default)(this, LocusInfo);

    // TODO: remove the locus as for delta its always incomplete
    this.updateMeeting = callback;
    this.controls = locus.controls || null;
    this.conversationUrl = locus.conversationUrl || null;
    this.created = locus.created || null;
    this.fullState = locus.fullState || null;
    this.host = locus.host || null;
    this.mediaShares = locus.mediaShares || null;
    this.participantsUrl = locus.participantsUrl || null;
    this.replaces = locus.replaces || null;
    this.url = locus.url || null;
    this.aclUrl = locus.aclUrl || null;
    this.baseSequence = locus.baseSequence || null;
    this.sequence = locus.sequence || null;
    this.membership = locus.membership || null;
    this.identities = locus.identities || null;
    this.emitChange = false;
    this.parsedLocus = {};
    this.spark = spark;

    this.updateMeetingInfo(locus.info);
    // self and participants generate sipUrl for 1:1 meeting
    this.updateSelf(locus.self, locus.participants);
    // this.self = locus.self || null;
    // this.info = locus.info || null;
  }

  (0, _createClass3.default)(LocusInfo, [{
    key: 'initialSetup',
    value: function initialSetup(locus, meeting) {
      // meeting already exisits just do an update
      if (meeting) {
        // Its a new delta event fetch the whole meeting object
        _parser2.default.updateWithDeltaLocus(locus, meeting);
      } else {
        this.onFullLocus(locus);
      }

      // Change it to true after it recives it first locus object
      this.emitChange = true;
    }
  }, {
    key: 'parse',
    value: function parse(meeting, data) {
      var eventType = data.eventType;

      switch (eventType) {
        case _constants.LOCUSEVENT.PARTICIPANT_JOIN:
        case _constants.LOCUSEVENT.PARTICIPANT_LEFT:
        case _constants.LOCUSEVENT.CONTROLS_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_AUDIO_MUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_AUDIO_UNMUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_VIDEO_MUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_VIDEO_UNMUTED:
        case _constants.LOCUSEVENT.SELF_CHANGED:
        case _constants.LOCUSEVENT.PARTICIPANT_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_CONTROLS_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_ROLES_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_DECLINED:
        case _constants.LOCUSEVENT.FLOOR_GRANTED:
        case _constants.LOCUSEVENT.FLOOR_RELEASED:
          this.onFullLocus(data.locus);
          break;
        case _constants.LOCUSEVENT.DIFFERENCE:
          _parser2.default.updateWithDeltaLocus(data.locus, meeting);
          break;

        default:
          // Why will there be a event with no eventType ????
          // we may not need this, we can get full locus
          _parser2.default.updateWithDeltaLocus(data.locus, meeting);
      }
    }
  }, {
    key: 'emitChanges',
    value: function emitChanges(type, object) {
      _events2.default.emit(type, object);
      // TODO: This will get triggred all the time when there is a
      // Valid object change but we need to decide when to emit it

      // {MeetingInfo} ploicyChange and type change
      // this.policy //
      // this.type: //
    }

    /**
     * updates the locus with full locus object
     * @param {object} locus locus object
     * @returns {object} null
     */

  }, {
    key: 'onFullLocus',
    value: function onFullLocus(locus) {
      this.updateLocusInfo(locus);
      this.updateParticipants(locus.participants);
    }
  }, {
    key: 'onDeltaLocus',
    value: function onDeltaLocus(locus) {
      this.updateLocusInfo(locus);
      this.updateParticipants(locus.participants, true);
    }
  }, {
    key: 'updateLocusInfo',
    value: function updateLocusInfo(locus) {
      this.updateControls(locus.controls);
      this.updateConversationUrl(locus.conversationUrl);
      this.updateCreated(locus.created);
      this.updateFullState(locus.state);
      this.updateHostInfo(locus.host);
      this.updateMeetingInfo(locus.info);
      this.updateMediaShares(locus.mediaShares);
      this.updateParticipantsUrl(locus.participantsUrl);
      this.updateReplace(locus.replace);
      this.updateSelf(locus.self, locus.participants);
      this.updateLocusUrl(locus.url);
      this.updateAclUrl(locus.aclUrl);
      this.updateBasequence(locus.baseSequence);
      this.updateSequence(locus.sequence);
      this.updateMemberShip(locus.membership);
      this.updateIdentifiers(locus.identities);
      // update which required to compare different objects from locus
    }

    /**
     *
     * @param {Object} participants new participants object
     * @param {boolen} deltaParticpantFlag  delta event
     * @returns {Array} updatedParticipants
     */

  }, {
    key: 'updateParticipants',
    value: function updateParticipants(participants, deltaParticpantFlag) {
      if (deltaParticpantFlag) {
        console.log('Delta participants came through');
      } else {
        console.log('Full locus participants came through');
      }
      this.emitChanges(_constants.EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, {
        participants: participants,
        selfId: this.parsedLocus.self.id,
        hostId: this.parsedLocus.host.id
      });
    }

    // // TODO: check if this causes any perfomance issue
    // findChangedParticipants(newParticipants) {
    //   // TODO: Handle case where if a user got added and removed then find the one added or removed
    //   if (newParticipants.length < 25) {
    //     const changedParticipants = [];
    //     this.participants.forEach((participant, index) => {
    //       // find if participant is in the array
    //       // find if any of the participant  got missed
    //       if (participant && !isEqual(participant, newParticipants[participant.id])) {
    //         this.participants[index] = newParticipants[participant.id];
    //         changedParticipants[participant.id] = participant;
    //       }
    //     });
    //     return changedParticipants;
    //   }
    //   // If more then 25 and we got fullLocus send Everything
    //   return this.participants;
    //   // TODO: find an alternate way or just replace the whole object
    //   // Tell customers that more then 25 we will just send an update
    // }

  }, {
    key: 'updateControls',
    value: function updateControls(controls) {
      if (controls && !(0, _isEqual3.default)(this.controls, controls)) {
        this.controls = controls;
        console.info('LocusInfo:controls got updated');
      }
    }
  }, {
    key: 'updateConversationUrl',
    value: function updateConversationUrl(conversationUrl) {
      if (conversationUrl && !(0, _isEqual3.default)(this.conversationUrl, conversationUrl)) {
        this.conversationUrl = conversationUrl;
        this.emitChanges(_constants.EVENTS.CONVERSATION_URL_UPDATE, conversationUrl);
        console.info('LocusInfo:conversationUrl got updated');
      }
    }
  }, {
    key: 'updateCreated',
    value: function updateCreated(created) {
      if (created && !(0, _isEqual3.default)(this.created, created)) {
        this.created = created;
        console.info('LocusInfo:created got updated');
      }
    }
  }, {
    key: 'updateFullState',
    value: function updateFullState(fullState) {
      if (fullState && !(0, _isEqual3.default)(this.fullState, fullState)) {
        // TODO: check what exactly is needed
        // active: true
        // count: 1
        // lastActive: "2019-02-01T16:52:26.764Z"
        // locked: false
        // sessionIds: []
        // state: "ACTIVE"
        // type: "CALL"

        // {
        //   'CALL'; // For 1:1 calls the type is CALL
        //   'MEETING'; // When Guest added the type is meeting
        //   'CALL'; // When guest user leaves
        // }
        this.fullState = fullState;
        console.info('LocusInfo:fullState got updated');
      }
    }

    /**
     * handles when the locus.host is updated
     * @param {Object} host the locus.host property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal event locus_info_update_host
     */

  }, {
    key: 'updateHostInfo',
    value: function updateHostInfo(host) {
      if (host && !(0, _isEqual3.default)(this.host, host)) {
        var parsedHosts = _hostUtils2.default.getHosts(this.host, host);
        this.updateMeeting(parsedHosts.current);
        this.parsedLocus.host = parsedHosts.current;
        if (parsedHosts.updates.isNewHost) {
          this.emitChanges(_constants.EVENTS.LOCUS_INFO_UPDATE_HOST, { newHost: parsedHosts.current, oldHost: parsedHosts.previous });
        }
        this.host = host;
        console.info('LocusInfo:host got updated');
      }
    }
  }, {
    key: 'updateMeetingInfo',
    value: function updateMeetingInfo(info) {
      if (info && !(0, _isEqual3.default)(this.info, info)) {
        this.info = info;
        var parsedInfo = _infoUtils2.default.parse(info);
        this.parsedLocus.info = parsedInfo;
        // Parses the info and adds necessary values
        this.updateMeeting(parsedInfo);
        console.info('LocusInfo:info got updated');
        this.emitChanges('infoUpdated');
      }
    }

    /**
     * handles when the locus.mediaShares is updated
     * @param {Object} mediaShares the locus.mediaShares property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal event locus_info_update_media_shares
     */

  }, {
    key: 'updateMediaShares',
    value: function updateMediaShares(mediaShares) {
      if (mediaShares && !(0, _isEqual3.default)(this.mediaShares, mediaShares)) {
        var parsedMediaShares = _mediaSharesUtils2.default.getMediaShares(this.mediaShares, mediaShares);
        this.updateMeeting(parsedMediaShares.current);
        this.emitChanges(_constants.EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, { current: parsedMediaShares.current, previous: parsedMediaShares.previous });
        this.parsedLocus.mediaShares = parsedMediaShares.current;
        this.mediaShares = mediaShares;
        console.info('LocusInfo:mediaShares got updated');
      }
    }
  }, {
    key: 'updateParticipantsUrl',
    value: function updateParticipantsUrl(participantsUrl) {
      if (participantsUrl && !(0, _isEqual3.default)(this.participantsUrl, participantsUrl)) {
        this.participantsUrl = participantsUrl;
        console.info('LocusInfo:participantsUrl got updated');
      }
    }
  }, {
    key: 'updateReplace',
    value: function updateReplace(replace) {
      if (replace && !(0, _isEqual3.default)(this.replace, replace)) {
        this.replace = replace;
        console.info('LocusInfo:replace got updated');
      }
    }

    /**
     * handles when the locus.self is updated
     * @param {Object} self the locus.mediaShares property
     * @param {Array} participants the locus.participants property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal events self_admitted_guest, self_unadmitted_guest, locus_info_update_self
     */

  }, {
    key: 'updateSelf',
    value: function updateSelf(self, participants) {
      if (self && !(0, _isEqual3.default)(this.self, self)) {
        var parsedSelves = _selfUtils2.default.getSelves(this.self, self, this.spark);
        this.updateMeeting(parsedSelves.current);
        this.updateMeeting(_selfUtils2.default.getSipUrl(self, participants, this.parsedLocus.info));
        if (parsedSelves.updates.isUnadmittedGuest) {
          this.emitChanges(_constants.EVENTS.SELF_UNADMITTED_GUEST, self);
        }
        if (parsedSelves.updates.isAdmittedGuest) {
          this.emitChanges(_constants.EVENTS.SELF_ADMITTED_GUEST, self);
        }
        this.emitChanges(_constants.EVENTS.LOCUS_INFO_UPDATE_SELF, { oldSelf: parsedSelves.previous, newSelf: parsedSelves.current });
        this.parsedLocus.self = parsedSelves.current;
        this.self = self;
        console.info('LocusInfo:self got updated');
      }
    }

    /**
     * handles when the locus.url is updated
     * @param {String} url
     * @returns {undefined}
     * emits internal event locus_info_update_url
     */

  }, {
    key: 'updateLocusUrl',
    value: function updateLocusUrl(url) {
      if (url && this.url !== url) {
        this.url = url;
        this.emitChanges(_constants.EVENTS.LOCUS_INFO_UPDATE_URL, url);
        console.info('LocusInfo:url got updated');
      }
    }
  }, {
    key: 'updateAclUrl',
    value: function updateAclUrl(aclUrl) {
      if (aclUrl && !(0, _isEqual3.default)(this.aclUrl, aclUrl)) {
        this.aclUrl = aclUrl;
        console.info('LocusInfo:aclUrl got updated');
      }
    }
  }, {
    key: 'updateBasequence',
    value: function updateBasequence(baseSequence) {
      if (baseSequence && !(0, _isEqual3.default)(this.baseSequence, baseSequence)) {
        this.baseSequence = baseSequence;
        console.info('LocusInfo:baseSequence got updated');
      }
    }
  }, {
    key: 'updateSequence',
    value: function updateSequence(sequence) {
      if (sequence && !(0, _isEqual3.default)(this.sequence, sequence)) {
        this.sequence = sequence;
        console.info('LocusInfo:sequence got updated');
      }
    }
  }, {
    key: 'updateMemberShip',
    value: function updateMemberShip(membership) {
      if (membership && !(0, _isEqual3.default)(this.membership, membership)) {
        this.membership = membership;
        console.info('LocusInfo:membership got updated');
      }
    }
  }, {
    key: 'updateIdentifiers',
    value: function updateIdentifiers(identities) {
      if (identities && !(0, _isEqual3.default)(this.identities, identities)) {
        this.identities = identities;
        console.info('LocusInfo:identities got updated');
      }
    }
  }]);
  return LocusInfo;
}();

exports.default = LocusInfo;
//# sourceMappingURL=index.js.map
