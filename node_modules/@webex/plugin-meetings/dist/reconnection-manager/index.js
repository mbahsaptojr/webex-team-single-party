'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _constants = require('../constants');

var _reconnection = require('../errors/reconnection');

var _reconnection2 = _interopRequireDefault(_reconnection);

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @export
 * @class ReconnectionManager
*/
var ReconnectionManager = function () {
  /**
   * @param {Meeting} meeting
   */
  function ReconnectionManager(meeting) {
    (0, _classCallCheck3.default)(this, ReconnectionManager);

    this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
    this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    this.configure(meeting);
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   */


  (0, _createClass3.default)(ReconnectionManager, [{
    key: 'configure',
    value: function configure(meeting) {
      this.backOff = meeting.config.reconnection.retry.backOff.start;
    }

    /**
     * @returns {undefined}
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
      this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    }

    /**
     * @param {Meeting} meeting
     * @returns {Boolean}
     * @returns {ReconnectionError}
     */

  }, {
    key: 'validate',
    value: function validate(meeting) {
      if (meeting.config.reconnection.enabled) {
        if (meeting.locusInfo && meeting.locusInfo.fullState && meeting.locusInfo.fullState.state === _constants.ACTIVE && meeting.locusInfo.fullState.active) {
          if (meeting.spark.internal.mercury.connected) {
            if (this.status !== _constants.RECONNECTION.STATE.DEFAULT_STATUS || this.status !== _constants.RECONNECTION.STATE.COMPLETE) {
              return true;
            }
            return new _reconnection2.default(new Error('Multiple reconnections cannot occur concurrently'));
          }
          return new _reconnection2.default(new Error('mercury is not connected, cannot reconnect'));
        }
        return new _reconnection2.default(new Error('locus server for this call is not active, cannot reconnect'));
      }
      return new _reconnection2.default(new Error('Reconnection is not enabled.'));
    }

    /**
     * @param {Meeting} meeting
     * @returns {Promise}
     */

  }, {
    key: 'reconnect',
    value: function reconnect(meeting) {
      var validatedReconnect = this.validate(meeting);
      return validatedReconnect === true ? this.execute(meeting) : _promise2.default.reject(validatedReconnect);
    }

    /**
     * @param {Meeting} meeting
     * @returns {Promise}
     */

  }, {
    key: 'execute',
    value: function execute(meeting) {
      var _this = this;

      this.status = _constants.RECONNECTION.STATE.IN_PROGRESS;
      return this.media(meeting).then(function (media) {
        console.info('Reconnection->Media reestablished at: ' + new Date());
        _this.status = _constants.RECONNECTION.STATE.COMPLETE;
        return _promise2.default.resolve(media);
      }).catch(function (err) {
        // eslint-disable-line
        console.info('Reconnection->Media reestablishment failed at: ' + new Date());
        if (_this.tryCount > meeting.config.reconnection.retry.times) {
          _this.status = _constants.RECONNECTION.STATE.FAILURE;
          return _promise2.default.reject(new _reconnection2.default(err));
        }
        // exponential backoff and retry logic
        setTimeout(function () {
          return _this.reconnect(meeting);
        }, _this.backOff *= meeting.config.reconnection.retry.backOff.rate);
      });
    }

    /**
     * @param {Meeting} meeting
     * @returns {Promise} see #Meeting.addMedia
     */

  }, {
    key: 'media',
    value: function media(meeting) {
      this.tryCount += 1;
      console.info('Reconnection->Re-establishing media at: ' + new Date());
      // create an offer
      return meeting.addMedia({
        mediaSettings: meeting.mediaProperties.mediaDirection
      }).then(function (media) {
        return _promise2.default.resolve(media);
      }).catch(function (err) {
        console.error('Could not re use peer connections for the media.', err);
        // TODO: test getting to this scenario
        ReconnectionManager.cleanup(meeting);
        return meeting.addMedia({
          mediaSettings: meeting.mediaProperties.mediaDirection,
          localStream: meeting.mediaProperties.localStream,
          localShare: meeting.mediaProperties.localShare
        });
      });
    }

    /**
     * @param {Meeting} meeting
     * @returns {undefined}
     */

  }], [{
    key: 'cleanup',
    value: function cleanup(meeting) {
      // close pcs, unset to null and reuse the streams with new pcs
      _peerConnectionManager2.default.close(meeting.mediaProperties.mediaPeerConnection);
      _peerConnectionManager2.default.close(meeting.mediaProperties.sharePeerConnection);
      meeting.mediaProperties.unsetPeerConnections();
    }
  }]);
  return ReconnectionManager;
}(); /*!
      * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
      */

exports.default = ReconnectionManager;
//# sourceMappingURL=index.js.map
