'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * @export
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 */
var Media = {}; /*!
                 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
                 */
/* globals navigator */

/* eslint-disable no-logger */


Media.setLocalTracks = function (audio, video, stream) {
  Media.setLocalAudioTracks(audio, stream);
  Media.setLocalVideoTracks(video, stream);
};

Media.setLocalAudioTracks = function (audio, stream) {
  if (stream) {
    if (stream.getAudioTracks) {
      var _stream$getAudioTrack = stream.getAudioTracks(),
          _stream$getAudioTrack2 = (0, _slicedToArray3.default)(_stream$getAudioTrack, 1),
          audioTrack = _stream$getAudioTrack2[0];

      if (audioTrack) {
        audioTrack.enabled = !audio.mute;
        return true;
      }
    }
  }
  return false;
};

Media.setLocalVideoTracks = function (video, stream) {
  if (stream) {
    if (stream.getVideoTracks) {
      var _stream$getVideoTrack = stream.getVideoTracks(),
          _stream$getVideoTrack2 = (0, _slicedToArray3.default)(_stream$getVideoTrack, 1),
          videoTrack = _stream$getVideoTrack2[0];

      if (videoTrack) {
        videoTrack.enabled = !video.mute;
        return true;
      }
    }
  }
  return false;
};

Media.generateLocalMedias = function (mediaId, audio, video) {
  if (mediaId) {
    return [{
      localSdp: (0, _stringify2.default)({
        audioMuted: audio.mute,
        videoMuted: video.mute
      }),
      mediaId: mediaId
    }];
  }
  return [];
};

Media.getLocalMedia = function (options) {
  var sendAudio = options.sendAudio,
      sendVideo = options.sendVideo,
      sendShare = options.sendShare;
  // we return undefined here as the second param until screen share is implemented

  if (sendAudio || sendVideo) {
    return Media.getMedia(sendAudio, sendVideo);
  }

  if (sendShare) {
    return Media.getDisplayMedia({
      sendAudio: false,
      sendShare: true
    });
  }

  return _promise2.default.resolve(undefined);
};
/**
 * creates peerconnection and attaches streams
 * @param {object} mediaDirection mediaDirection
 * @param {Object} pcManager peerConnectionManager instance
 * @param {Object} audioVideo audioVideo streams
 * @param {Object} localShare sendScreen: {Boolean} sendShare constraints
 * @param {Object} mappedPCs {mediaPeerConnection, sharePeerConnection}
 * @returns {Array} [mediaPeerConnection, sharePeerConnection ]
 */
Media.attachMedia = function (mediaDirection, pcManager, audioVideo, localShare) {
  var mappedPCs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var promises = [];
  // Create a peer
  if (mediaDirection.receiveVideo || mediaDirection.receiveAudio || audioVideo) {
    promises.push(pcManager.createOffer({
      receiveAudio: mediaDirection.receiveAudio,
      receiveVideo: mediaDirection.receiveVideo,
      // After you get the localStream
      streams: audioVideo,
      peerConnection: mappedPCs.mediaPeerConnection
    }));
  } else {
    promises.push(undefined);
  }

  if (mediaDirection.receiveShare || localShare) {
    promises.push(pcManager.createOffer({
      // its for screen sharing but can change in future when user wants just share with audio
      receiveAudio: false,
      receiveVideo: mediaDirection.receiveShare,
      // After you get the localStream
      streams: localShare,
      peerConnection: mappedPCs.sharePeerConnection
    }));
  }
  return _promise2.default.all(promises);
};
/**
 * generates share streams (chrome)
 * @param {object} options parameter
 * @param {Object} options.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} options.sendScreen sendScreen: {Boolean} sendShare constraints
 * @returns {Object} {streams}
 */
Media.getDisplayMedia = function (options) {
  return navigator.mediaDevices.getDisplayMedia({ audio: options.sendAudio, video: options.sendScreen });
};

/**
 * generates audio and video using constraints (often called after getSupportedDevices)
 * @param {Object} audio audio: {Boolean} gum constraints
 * @param {Object} video video: {Boolean} gum constraints
 * @returns {Object} {streams}
 */
Media.getMedia = function (audio, video) {
  var mediaConfig = {
    audio: audio,
    video: video
  };

  return new _promise2.default(function (resolve, reject) {
    navigator.mediaDevices.getUserMedia(mediaConfig).then(function (stream) {
      resolve(stream);
    }).catch(function (err) {
      reject(new Error({
        name: err.name,
        localMediaFailed: true,
        cameraFailed: err === mediaConfig.permissionDenied
      }));
    });
  });
};

/**
 * Checks if the machine has at least one audio or video device (Dont use this for screen share)
 * @param {object} options optional parameter
 * {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 * }
 * @returns {Object} {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 *}
 */
Media.getSupportedDevice = function (_ref) {
  var sendAudio = _ref.sendAudio,
      sendVideo = _ref.sendVideo;
  return _promise2.default.resolve().then(function () {
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return {
        sendAudio: true,
        sendVideo: true
      };
    }

    return navigator.mediaDevices.enumerateDevices().then(function (devices) {
      var supported = {
        audio: devices.filter(function (device) {
          return device.kind === _constants.AUDIO_INPUT;
        }).length > 0,
        video: devices.filter(function (device) {
          return device.kind === _constants.VIDEO_INPUT;
        }).length > 0
      };
      return {
        sendAudio: supported.audio && sendAudio || true,
        sendVideo: supported.video && sendVideo || true
      };
    });
  });
};

/**
 *
 * Toggle a specific stream
 * @returns {null}
 */
Media.toggleStream = function () {};

/**
 *
 * Stop input stream
 * @param {Stream} stream A media stream
 * @returns {null}
 * @memberof Media
 */
Media.stopStream = function (stream) {
  if (!stream) {
    return _promise2.default.resolve();
  }
  /*
   * To release local media
   * 1) Chrome requires all tracks to be stopped (stream.stop got deprecated)
   * 2) Firefox requires the stream to be stopped
   */
  return _promise2.default.resolve().then(function () {
    if (stream.getTracks) {
      stream.getTracks().forEach(function (track) {
        track.stop();
      });
    } else if (stream.stop) {
      stream.stop();
    }
  });
};

/**
 * generates streams for audio video and share
 * @param {object} mediaSetting parameter
 * @param {Object} mediaSetting.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} mediaSetting.sendVideo sendVideo: {Boolean} sendVideo constraints
 * @param {Object} mediaSetting.sendScreen sendScreen: {Boolean} sendShare constraints
 * @returns {Array} [localStream, shareStream]
 */
Media.getUserMedia = function (mediaSetting) {
  return Media.getLocalMedia({
    sendAudio: mediaSetting.sendAudio,
    sendVideo: mediaSetting.sendVideo
  }).then(function (localStream) {
    return Media.getLocalMedia({
      sendShare: mediaSetting.sendShare
    }).then(function (shareStream) {
      return [localStream, shareStream];
    });
  });
};

exports.default = Media;
//# sourceMappingURL=index.js.map
