'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _sparkCore = require('@ciscospark/spark-core');

var _collection = require('../meetings/collection');

var _collection2 = _interopRequireDefault(_collection);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _constants = require('../constants');

var _util = require('../roap/util');

var _util2 = _interopRequireDefault(_util);

var _collection3 = require('../roap/collection');

var _collection4 = _interopRequireDefault(_collection3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-console,no-param-reassign */
var checkForAndHandleErrors = function checkForAndHandleErrors(action, meeting, correlationId) {
  if (action && action.type) {
    if (action.msg && action.msg.messageType && action.msg.errorType) {
      if (_util2.default.findError(action.msg.messageType, action.msg.errorType, action.type)) {
        _util2.default.handleError(meeting.mediaProperties.mediaPeerConnection).then(function (res) {
          if (res) {
            _collection4.default.deleteSessionSequence(correlationId, action.msg.seq);
          }
        }).catch(function (err) {
          undefined.logger.info('Cannot reset the peer connection', err);
        });
        return true;
      }
    }
    if (!_util2.default.ensureMeeting(meeting, action.type)) {
      return true;
    }
  }
  return false;
};

var handleSessionStep = function handleSessionStep(roap, session) {
  var _roap$msg = roap.msg,
      sequenceId = _roap$msg.seq,
      messageType = _roap$msg.messageType;

  if (session.OFFER && messageType === _constants.OFFER) {
    session.GLARE_OFFER = roap.msg;
    session.GLARE_OFFER.remote = !!roap.remote;
    console.info('Its a GLARE condition seq:' + sequenceId + ' new mercury event');
  } else {
    console.info('Save OFFER/ANSWER seq:' + sequenceId + ' new mercury event ' + messageType + 'local state: ' + (0, _stringify2.default)(session.state.state, null, 2));
    session[messageType] = roap.msg;
    session[messageType].remote = !!roap.remote;
  }
};
/**
 * @class RoapHandler
 */

var RoapHandler = function (_StatelessSparkPlugin) {
  (0, _inherits3.default)(RoapHandler, _StatelessSparkPlugin);

  function RoapHandler() {
    (0, _classCallCheck3.default)(this, RoapHandler);
    return (0, _possibleConstructorReturn3.default)(this, (RoapHandler.__proto__ || (0, _getPrototypeOf2.default)(RoapHandler)).apply(this, arguments));
  }

  (0, _createClass3.default)(RoapHandler, [{
    key: 'perform',

    /**
     *
     * @param {Object} session
     * @param {Meeting} meeting
     * @param {Object} action
     * @returns {null}
     */
    value: function perform(session, meeting, action) {
      var _this2 = this;

      switch (session.state.state) {
        // case ROAP.ROAP_STATE.INIT:
        // case ROAP.ROAP_STATE.WAIT_RX_OFFER:
        // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
        // case ROAP.ROAP_STATE.WAIT_RX_OK:
        case _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER:
          // eslint-disable-next-line no-warning-comments
          // TODO: sometime the you get an answer while you are creating an offer so SKIP
          // Server will send the mercury event comes back
          if (_util2.default.shouldHandleMedia(meeting)) {
            _util2.default.updatePeerConnection(meeting, session).then(function (answerSdps) {
              _events2.default.emit(_constants.EVENTS.ROAP_ANSWER, {
                locusId: meeting.locusId,
                locusSelfId: meeting.locusInfo.self.id,
                mediaId: meeting.mediaId,
                sdps: answerSdps,
                seq: session.OFFER.seq,
                correlationId: meeting.correlationId,
                audioMuted: meeting.isAudioMuted(),
                videoMuted: meeting.isVideoMuted()
              });
            }).catch(function (err) {
              _this2.logger.error(err);
            });
          }
          break;
        case _constants.ROAP.ROAP_STATE.WAIT_TX_OK:
          _util2.default.setRemoteDescription(meeting, session).then(function (res) {
            _events2.default.emit(_constants.EVENTS.ROAP_OK, res);
          });
          break;
        // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:
        case _constants.ROAP.ROAP_STATE.ERROR:
          this.logger.error('Call-RoapHandler#ERROR state=error', session);
          break;
        case _constants.ROAP.ROAP_STATE.GLARE:
          session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
          session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
          this.logger.error('Resolve the GLARE condition');
          if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
            // 2
            this.logger.error('local offer wins');
          } else {
            this.logger.error('remote offer wins', session);
          }
          session.state.step(_constants.ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, action);
          this.perform(session, meeting);
          break;
        default:
          break;
      }
    }

    /**
     *
     * @param {String} signal
     * @param {Object} session
     * @param {Object} action
     * @param {Meeting} meeting
     * @param {String} prefix
     * @returns {null}
     */

  }, {
    key: 'execute',
    value: function execute(signal, session, action, meeting, prefix) {
      if (session && session.state) {
        handleSessionStep(action, session);
        signal = _constants.ROAP.ROAP_SIGNAL['' + prefix + action.msg.messageType];
        session.state.step(signal, meeting, action);
        this.perform(session, meeting, action);
      }
    }

    /**
     *
     * @param {Object} session
     * @param {Object} action
     * @param {Meeting} meeting
     * @param {String} correlationId
     * @returns {Boolean}
     */

  }, {
    key: 'handleAction',
    value: function handleAction(session, action, meeting, correlationId) {
      var signal = void 0;
      switch (action.type) {
        case _constants.ROAP.RECEIVE_ROAP_MSG:
          action.remote = true;
          this.execute(signal, session, action, meeting, _constants.ROAP.RX_);
          break;
        case _constants.ROAP.SEND_ROAP_MSG:
          action.local = true;
          this.execute(signal, session, action, meeting, _constants.ROAP.TX_);
          break;
        case _constants.ROAP.SEND_ROAP_MSG_SUCCESS:
          // This means we got and answer and waiting for 200 ok for /participants
          if (_collection4.default.getSessionSequence(correlationId, action.seq).ANSWER) {
            signal = _constants.ROAP.ROAP_SIGNAL.RX_ANSWER;
            // NOTE: When server send back an answer via mercury the
            // remote SDP is already saved sent and ok message is sent back
            // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
            // RoapHandler.transition(signal, session, meeting);
          }
          break;
        case 'RECEIVE_CALL_LEAVE':
          _collection4.default.deleteSession(correlationId);
          console.info('Call-this#RECEIVE_CALL_LEAVE: cleaning up the RoapHandler', correlationId);
          break;
        case _constants.ROAP.RESET_ROAP_STATE:
          _collection4.default.deleteSessionSequence(correlationId, action.msg.seq);
          console.info('Call-RoapHandler#RESET_ROAP_STATE: resetting the RoapHandler state', action.msg.seq);
          break;
        default:
          return true;
      }
      return true;
    }

    /**
     *
     * @param {Object} action
     * @returns {Boolean}
     */

  }, {
    key: 'submit',
    value: function submit(action) {
      var correlationId = action.correlationId;

      var session = _collection4.default.getSessionSequence(correlationId, action.seq || action.msg.seq);
      var meeting = _collection2.default.get(correlationId);
      if (checkForAndHandleErrors(action, meeting, correlationId)) {
        return true;
      }
      return this.handleAction(session, action, meeting, correlationId);
    }
  }]);
  return RoapHandler;
}(_sparkCore.StatelessSparkPlugin);

exports.default = RoapHandler;
//# sourceMappingURL=handler.js.map
