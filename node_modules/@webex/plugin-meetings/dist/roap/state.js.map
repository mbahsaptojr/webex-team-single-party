{"version":3,"sources":["state.js"],"names":["shouldStep","roap","meeting","messageType","msg","OFFER","remote","shareStatus","REQUESTED","mediaProperties","mediaPeerConnection","sharePeerConnection","ANSWER","console","info","handleTransition","value","signal","ROAP","ROAP_STATE","INIT","ROAP_SIGNAL","RX_OFFER","WAIT_TX_ANSWER","TX_OFFER","WAIT_RX_ANSWER","WAIT_RX_OFFER","RX_ANSWER","mediaId","WAIT_TX_OK","error","GLARE","WAIT_TX_OFFER","TX_ANSWER","WAIT_RX_OK","TX_OK","RX_OK","ERROR","RoapStateMachine","createState","RoapState","StateMachine","factory","init","transitions","name","ROAP_TRANSITIONS","STEP","from","to","state","methods","onAfterStep","transition","log","event"],"mappings":"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","file":"state.js","sourcesContent":["/* eslint-disable no-console */\n// we need to figure out how to pass a spark logger instace to these util files\n\nimport StateMachine from 'javascript-state-machine';\n\nimport {ROAP, OFFER, ANSWER, REQUESTED} from '../constants';\n\nconst shouldStep = (roap, meeting) => {\n  const {messageType} = roap.msg;\n  if (meeting) {\n    if (messageType === OFFER && roap.remote && meeting.shareStatus === REQUESTED) {\n      // The peer-connection is waiting for answer but got an offer Reset. Try to\n      // send the offer later after you accept the answer\n      return false;\n    }\n    // Assuming the mercury event has come first before the response for the event\n    // we have to wait for the response and trigger the ROAP request later on\n    if (!meeting.mediaProperties.mediaPeerConnection && !meeting.mediaProperties.sharePeerConnection && messageType === ANSWER) {\n      return false;\n    }\n  }\n  console.info('Call-RoapHandler: success save proceeding with transition, ', roap.msg);\n  return true;\n};\n\nconst handleTransition = (value, signal, meeting) => {\n  switch (value) {\n    case ROAP.ROAP_STATE.INIT:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_TX_ANSWER;\n      }\n      if (signal === ROAP.ROAP_SIGNAL.TX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n      }\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.RX_ANSWER) {\n        // There is a race condition where the /call response comes after mercury event from the server\n        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that\n        if (meeting.mediaId) {\n          return ROAP.ROAP_STATE.WAIT_TX_OK;\n        }\n        console.error('Call-RoapHandler#Race Condition no mediaId');\n        return value;\n      }\n\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.GLARE;\n      }\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.TX_ANSWER) {\n        return ROAP.ROAP_STATE.WAIT_RX_OK;\n      }\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.TX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n      return value;\n\n    case ROAP.ROAP_STATE.ERROR:\n      // eslint-disable-next-line no-warning-comments\n      // TODO: resolve error state. Add a signal constant and handle the cleanup\n      return ROAP.ROAP_STATE.INIT;\n\n    case ROAP.ROAP_STATE.GLARE:\n      return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n    default:\n      return value;\n  }\n};\n\nconst RoapStateMachine = {\n  /**\n   * initializes the state machine\n   * @returns {StateMachine} an instance of a state machine\n   */\n  createState() {\n    const RoapState = StateMachine.factory({\n      init: ROAP.ROAP_STATE.INIT,\n      transitions: [\n        {\n          name: ROAP.ROAP_TRANSITIONS.STEP,\n          from: '*',\n          /**\n           * Method to handle the transitions between states\n           * @param {String} signal\n           * @param {Meeting} meeting instance of a Meeting\n           * @param {Object} roap\n           * @returns {String} new state value\n           */\n          to(signal, meeting, roap) {\n            const value = this.state;\n            if (!shouldStep(roap, meeting)) {\n              return value;\n            }\n            return handleTransition(value, signal, meeting);\n          }\n        }\n      ],\n      methods: {\n        /**\n         * Event that fires after we've transitioned to a new state\n         * @param {Object} transition\n         * @returns {null}\n         */\n        onAfterStep(transition) {\n          console.log(\n            `roap:state#onAfterStep->${transition.event} fired! State changed from '${transition.from}' to '${\n              transition.to\n            }' with transition '${transition.transition}''.`\n          );\n        }\n      }\n    });\n    return new RoapState();\n  }\n};\n\nexport default RoapStateMachine;\n"]}