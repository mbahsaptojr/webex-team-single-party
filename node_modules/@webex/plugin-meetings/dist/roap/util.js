'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-console */
// we need to figure out how to pass a spark logger instace to these util files

var RoapUtil = {};
var ROAP_ANSWER = _constants.ANSWER.toLowerCase();

RoapUtil.shouldHandleMedia = function (meeting) {
  var mediaOffer = meeting.mediaProperties.mediaPeerConnection && meeting.mediaProperties.mediaPeerConnection.signalingState === _constants.SDP.HAVE_LOCAL_OFFER;
  var screenOffer = meeting.mediaProperties.sharePeerConnection && meeting.mediaProperties.sharePeerConnection.signalingState === _constants.SDP.HAVE_LOCAL_OFFER;
  if (mediaOffer || screenOffer) {
    return false;
  }
  return true;
};

RoapUtil.handleError = function (pc) {
  return _peerConnectionManager2.default.rollBackLocalDescription({ mediaPeerConnection: pc }).then(function () {
    return _promise2.default.resolve(true);
  }).catch(function (err) {
    return _promise2.default.reject(err);
  });
};

RoapUtil.findError = function (messageType, errorType, type) {
  return (type === _constants.ROAP.RECEIVE_ROAP_MSG || type === _constants.ROAP.SEND_ROAP_MSG) && messageType === _constants.ERROR && errorType === _constants.CONFLICT;
};

RoapUtil.ensureMeeting = function (meeting, type) {
  if (type === _constants.ROAP.RECEIVE_ROAP_MSG || type === _constants.ROAP.SEND_ROAP_MSG || type === _constants.ROAP.SEND_ROAP_MSG_SUCCESS) {
    if (!meeting) {
      return false;
    }
  }
  return true;
};

RoapUtil.compareLastRemoteOffer = function (currentOffer, previousOffer) {
  var index1 = void 0,
      index2 = void 0;
  var difference = false;

  if (previousOffer.length > 0 && previousOffer.length === currentOffer.length) {
    console.log('previous offer', previousOffer[0].slice(0, 20));
    console.log('current offer', currentOffer[0].slice(0, 20));
    previousOffer.forEach(function (sdp, index) {
      index1 = sdp.indexOf('IN');
      index2 = currentOffer[index].indexOf('IN');

      if (sdp.substring(index1) !== currentOffer[index].substring(index2)) {
        difference = true;
      }
    });
  }
  return difference;
};

RoapUtil.updatePeerConnection = function (meeting, session) {
  var res = RoapUtil.compareLastRemoteOffer(session.OFFER.sdps, meeting.roap.lastRoapOffer);
  if (!res) {
    var sdpPromises = [];
    if (meeting.mediaProperties.mediaPeerConnection) {
      sdpPromises.push(meeting.mediaProperties.mediaPeerConnection.sdp);
    }
    if (meeting.mediaProperties.sharePeerConnection) {
      sdpPromises.push(meeting.mediaProperties.sharePeerConnection.sdp);
    }
    return _promise2.default.resolve(sdpPromises);
  }
  return _peerConnectionManager2.default.updatePeerConnection({
    offerSdp: session.OFFER.sdps,
    pc: meeting.mediaProperties.mediaPeerConnection,
    sharePeerConnection: meeting.mediaProperties.sharePeerConnection,
    offerToReceiveAudio: true,
    offerToReceiveVideo: true
  }).then(function (res) {
    meeting.roap.lastRoapOffer = session.OFFER.sdps;
    return res;
  });
};

RoapUtil.setRemoteDescription = function (meeting, session) {
  console.info('Call-RoapHandler: Transmite WAIT_TX_OK', meeting.correlationId);
  if (!(meeting && (meeting.mediaProperties.mediaPeerConnection || meeting.mediaProperties.sharePeerConnection))) {
    console.error('Call-RoapHandler: DANGER no media or screen peer connection', meeting.correlationId);
    return _promise2.default.reject(new Error('Must provide a media or screen peer connection'));
  }
  var promise = void 0;
  if (meeting.mediaProperties.mediaPeerConnection && meeting.mediaProperties.sharePeerConnection) {
    promise = _promise2.default.all([_peerConnectionManager2.default.setRemoteSessionDetails(meeting.mediaProperties.mediaPeerConnection, ROAP_ANSWER, session.ANSWER.sdps[0], meeting.clientIdentifiers), _peerConnectionManager2.default.setRemoteSessionDetails(meeting.mediaProperties.sharePeerConnection, ROAP_ANSWER, session.ANSWER.sdps[1], meeting.clientIdentifiers)]);
  } else if (meeting.mediaProperties.sharePeerConnection) {
    promise = _peerConnectionManager2.default.setRemoteSessionDetails(meeting.mediaProperties.sharePeerConnection, ROAP_ANSWER, session.ANSWER.sdps[0], meeting.clientIdentifiers);
  }
  return promise.then(function () {
    console.info('Call-RoapHandler: setRemote Description successfull', meeting.correlationId);
    return {
      seq: session.ANSWER.seq,
      locusId: meeting.locusId,
      locusSelfId: meeting.locusInfo.self.id,
      mediaId: meeting.mediaId,
      correlationId: meeting.correlationId
    };
  }).catch(function (err) {
    console.error('Call-RoapHandler: Error setting remote and sending Roap Message', err);
    throw err;
  });
};

exports.default = RoapUtil;
//# sourceMappingURL=util.js.map
