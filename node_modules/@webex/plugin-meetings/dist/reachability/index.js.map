{"version":3,"sources":["index.js"],"names":["Reachability","attrs","options","namespace","MEETINGS","setup","processedClusterResults","peerConnectionMap","gatherReachability","window","localStorage","setItem","REACHABILITY","reachabilityRequest","getClusters","then","clusters","performReachabilityCheck","response","catch","error","console","info","log","clusterList","length","resolve","localSDPList","getLocalSDPForClusters","localSDPData","peerConnection","setRemoteOfferForEachCluster","iceResult","remoteSDPForClusters","remoteSDPResponse","remoteSDPList","answers","cleanUpPeerConnections","forEach","remoteSdp","jsonObj","clusterId","sdp","pc","setIceCallBackHandlers","iceStatsResult","push","start","iceStats","stop","reachabilityResult","parseIceResultToReachabilityResult","peerConnectionManager","setRemoteSessionDetails","_ANSWER_","reject","cluster","createOffer","receiveAudio","receiveVideo","localSDP","Error","result","reachability","latency","reachable","latencyInMilliseconds","udp","key","close","timeout","iceComplete","isSuccessful","clearTimeout","undefined","setTimeout","oniceconnectionstatechange","iceConnectionState","ICE_STATE","CHECKING","Date","now","CONNECTED","FAILED","ReachabilityRequest","StatelessSparkPlugin"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;AAEA;;;;AACA;;AAEA;;;;;;AAEA;;;;AAZA;;;;AAIA;IAWqBA,Y;;;AAGnB,wBAAYC,KAAZ,EAAmBC,OAAnB,EAA4B;AAAA;;AAAA,kJACpB,EADoB,EAChBA,OADgB;;AAAA,UAF5BC,SAE4B,GAFhBC,mBAEgB;;AAAA,UAK5BC,KAL4B,GAKpB,YAAM;AACZ,YAAKC,uBAAL,GAA+B,EAA/B;AACA,YAAKC,iBAAL,GAAyB,EAAzB;AACD,KAR2B;;AAAA,UAc5BC,kBAd4B,GAcP,YAAM;AACzB,YAAKH,KAAL;AACA;AACA,UAAI;AACFI,eAAOC,YAAP,CAAoBC,OAApB,CAA4BC,wBAAaF,YAAzC,EAAuD,yBAAe,EAAf,CAAvD;;AAEA;AACA,eAAO,MAAKG,mBAAL,CAAyBC,WAAzB,GACJC,IADI,CACC,UAACC,QAAD;AAAA;AACJ;AACA,kBAAKC,wBAAL,CAA8BD,QAA9B,EACGD,IADH,CACQ,UAACG,QAAD,EAAc;AAClBT,qBAAOC,YAAP,CAAoBC,OAApB,CAA4BC,wBAAaF,YAAzC,EAAuD,yBAAeQ,QAAf,CAAvD;AACA,qBAAOA,QAAP;AACD,aAJH;AAFI;AAAA,SADD,EAQJC,KARI,CAQE,UAACC,KAAD,EAAW;AAChBC,kBAAQC,IAAR,sCAAgDF,KAAhD;AACA,iBAAO,EAAP;AACD,SAXI,CAAP;AAYD,OAhBD,CAiBA,OAAOA,KAAP,EAAc;AACZC,gBAAQE,GAAR,CAAY,iDAAZ,EAA+DH,KAA/D;AACA,eAAO,EAAP;AACD;AACF,KAtC2B;;AAAA,UA6C5BH,wBA7C4B,GA6CD,UAACO,WAAD,EAAiB;AAC1C,UAAI,CAACA,WAAD,IAAgB,CAACA,YAAYC,MAAjC,EAAyC;AACvC,eAAO,kBAAQC,OAAR,CAAgB,EAAhB,CAAP;AACD;;AAED,UAAIC,eAAe,EAAnB;;AAEA,aAAO,sBAAa,UAACD,OAAD,EAAa;AAC/B,cAAKE,sBAAL,CAA4BJ,WAA5B,EACGT,IADH,CACQ,UAACc,YAAD,EAAkB;AACtB,cAAI,CAACA,YAAD,IAAiB,CAAC,oBAAYA,YAAZ,EAA0BJ,MAA5C,IAAsD,CAACI,aAAaF,YAApE,IAAoF,CAACE,aAAaC,cAAtG,EAAsH;AACpH;AACAT,oBAAQC,IAAR,CAAa,wDAAb;AACAI,oBAAQ,EAAR;AACD;;AAED,gBAAKnB,iBAAL,GAAyBsB,aAAaC,cAAtC;AACEH,sBARoB,GAQJE,YARI,CAQpBF,YARoB;;AAStB,gBAAKI,4BAAL,CAAkCJ,YAAlC,EACGZ,IADH,CACQ,UAACG,QAAD,EAAc;AAClBQ,oBAAQR,QAAR;AACD,WAHH;AAID,SAdH,EAeGC,KAfH,CAeS,UAACC,KAAD,EAAW;AAChBC,kBAAQD,KAAR,uCAAkDA,KAAlD;AACAM,kBAAQ,EAAR;AACD,SAlBH;AAmBD,OApBM,CAAP;AAqBD,KAzE2B;;AAAA,UAgF5BK,4BAhF4B,GAgFG,UAACJ,YAAD,EAAkB;AAC/C,UAAMK,YAAY,EAAlB;AACA,aAAO,sBAAY,UAACN,OAAD,EAAa;AAC9B,cAAKb,mBAAL,CAAyBoB,oBAAzB,CAA8CN,YAA9C,EACGZ,IADH,CACQ,UAACmB,iBAAD,EAAuB;AAC3B,cAAMC,gBAAgBD,kBAAkBE,OAAxC;AACA,cAAI,CAACD,aAAD,IAAkB,CAACA,cAAcV,MAArC,EAA6C;AAC3CJ,oBAAQC,IAAR,CAAa,sBAAb;AACA,kBAAKe,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAmB,oBAAQ,EAAR;AACD;AACDS,wBAAcG,OAAd,CAAsB,UAACC,SAAD,EAAe;AACnC,gBAAMC,UAAUD,SAAhB;AADmC,gBAE5BE,SAF4B,GAEfD,OAFe,CAE5BC,SAF4B;;;AAInC,gBAAID,WAAWA,QAAQE,GAAvB,EAA4B;AAC1B,kBAAMC,KAAK,MAAKpC,iBAAL,CAAuBkC,SAAvB,CAAX;;AAEA,oBAAKG,sBAAL,CAA4BD,EAA5B,EACG5B,IADH,CACQ,UAAC8B,cAAD,EAAoB;AACxBA,+BAAeJ,SAAf,GAA2BA,SAA3B;AACA,sBAAKnC,uBAAL,CAA6BwC,IAA7B,CAAkCD,eAAeJ,SAAjD;AACAT,0BAAUa,eAAeJ,SAAzB,IAAsC;AACpCM,yBAAOF,eAAeG,QAAf,CAAwBD,KADK;AAEpCE,wBAAMJ,eAAeG,QAAf,CAAwBC;AAFM,iBAAtC;;AAKA,oBAAI,MAAK3C,uBAAL,CAA6BmB,MAA7B,KAAwCU,cAAcV,MAA1D,EAAkE;AAChE,sBAAMyB,qBAAqB,MAAKC,kCAAL,CAAwCnB,SAAxC,CAA3B;AACAX,0BAAQC,IAAR,mCAA6C,yBAAe4B,kBAAf,CAA7C;AACAxB,0BAAQwB,kBAAR;AACD;AACF,eAdH,EAeG/B,KAfH,CAeS,UAACC,KAAD,EAAW;AAChBC,wBAAQD,KAAR,qCAAgDA,KAAhD;AACA,sBAAKiB,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAmB,wBAAQ,EAAR;AACD,eAnBH;AAoBA0B,8CAAsBC,uBAAtB,CAA8CV,EAA9C,EAAkDW,mBAAlD,EAA4Dd,QAAQE,GAApE;AACD,aAxBD,MAyBK;AACHrB,sBAAQC,IAAR,CAAgBmB,SAAhB;AACA,oBAAKnC,uBAAL,CAA6BwC,IAA7B,CAAkCL,SAAlC;AACA,kBAAI,MAAKnC,uBAAL,CAA6BmB,MAA7B,KAAwCU,cAAcV,MAA1D,EAAkE;AAChE,sBAAKY,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAmB,wBAAQ,EAAR;AACD;AACF;AACF,WArCD;AAsCD,SA9CH,EA+CGP,KA/CH,CA+CS,UAACC,KAAD,EAAW;AAChBC,kBAAQD,KAAR,qCAAgDA,KAAhD;AACA,gBAAKiB,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAmB,kBAAQ,EAAR;AACD,SAnDH;AAoDD,OArDM,CAAP;AAsDD,KAxI2B;;AAAA,UA+I5BE,sBA/I4B,GA+IH,UAACJ,WAAD,EAAiB;AACxC,UAAMK,eAAe,EAArB;AACA,UAAMF,eAAe,EAArB;AACA,UAAMpB,oBAAoB,EAA1B;;AAEA,aAAO,sBAAa,UAACmB,OAAD,EAAU6B,MAAV,EAAqB;AACvC/B,oBAAYc,OAAZ,CAAoB,UAACkB,OAAD,EAAa;AAC/B,cAAMf,YAAYe,OAAlB;;AAEAJ,0CAAsBK,WAAtB,CAAkC,EAACC,cAAc,IAAf,EAAqBC,cAAc,KAAnC,EAAlC,EACG5C,IADH,CACQ,UAACe,cAAD,EAAoB;AACxBvB,8BAAkBkC,SAAlB,IAA+BX,cAA/B;;AAEA,gBAAM8B,WAAW;AACflB,mBAAKZ,eAAeY,GADL;AAEfD;AAFe,aAAjB;;AAKAd,yBAAamB,IAAb,CAAkBc,QAAlB;;AAEA,gBAAIjC,aAAaF,MAAb,KAAwBD,YAAYC,MAAxC,EAAgD;AAC9CI,2BAAaC,cAAb,GAA8BvB,iBAA9B;AACAsB,2BAAaF,YAAb,GAA4BA,YAA5B;AACAD,sBAAQG,YAAR;AACD;AACF,WAhBH,EAiBGV,KAjBH,CAiBS,UAACC,KAAD,EAAW;AAChBmC,mBAAO,IAAIM,KAAJ,6BAAoCzC,KAApC,CAAP;AACAC,oBAAQD,KAAR,6BAAwCA,KAAxC;AACD,WApBH;AAqBD,SAxBD;AAyBD,OA1BM,CAAP;AA2BD,KA/K2B;;AAAA,UAsL5B+B,kCAtL4B,GAsLS,UAACnB,SAAD,EAAe;AAClD,UAAI,CAACA,SAAD,IAAc,CAAC,oBAAYA,SAAZ,EAAuBP,MAA1C,EAAkD;AAChD,eAAO,EAAP;AACD;AACD,UAAMqC,SAAS,EAAf;AAJkD;AAAA;AAAA;;AAAA;AAKlD,wDAAwB,oBAAY9B,SAAZ,CAAxB,4GAAgD;AAAA,cAArCS,SAAqC;;AAC9C,cAAIsB,eAAe,EAAnB;AACA,cAAI/B,UAAUS,SAAV,EAAqBM,KAArB,GAA6B,CAA7B,IAAkCf,UAAUS,SAAV,EAAqBQ,IAArB,GAA4B,CAAlE,EAAqE;AACnE,gBAAMe,UAAUhC,UAAUS,SAAV,EAAqBQ,IAArB,GAA4BjB,UAAUS,SAAV,EAAqBM,KAAjE;AACAgB,2BAAe;AACbE,yBAAW,IADE;AAEbC,qCAAuBF;AAFV,aAAf;AAID,WAND,MAOK;AACHD,2BAAe,EAACE,WAAW,KAAZ,EAAf;AACD;AACDH,iBAAOrB,SAAP,IAAoB,EAAC0B,KAAKJ,YAAN,EAApB;AACD;AAlBiD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmBlD,aAAOD,MAAP;AACD,KA1M2B;;AAAA,UAiN5BzB,sBAjN4B,GAiNH,UAAC9B,iBAAD,EAAuB;AAAA;AAAA;AAAA;;AAAA;AAC9C,yDAAkB,oBAAYA,iBAAZ,CAAlB,iHAAkD;AAAA,cAAvC6D,GAAuC;;AAChD,cAAMzB,KAAKpC,kBAAkB6D,GAAlB,CAAX;AACA,cAAIzB,EAAJ,EAAQ;AACNtB,oBAAQC,IAAR,wDAAkE8C,GAAlE;AACAzB,eAAG0B,KAAH;AACD;AACF;AAP6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQ/C,KAzN2B;;AAAA,UAgO5BzB,sBAhO4B,GAgOH,UAACD,EAAD,EAAQ;AAC/B,UAAI2B,UAAU,IAAd;AACA,UAAMtB,WAAW,EAACD,OAAO,CAAR,EAAWE,MAAM,CAAjB,EAAjB;AACA,aAAO,sBAAa,UAACvB,OAAD,EAAa;AAC/B,iBAAS6C,WAAT,CAAqBC,YAArB,EAAmCF,OAAnC,EAA4CtB,QAA5C,EAAsD;AACpD,cAAIwB,YAAJ,EAAkB;AAChB,gBAAIF,OAAJ,EAAa;AACX7D,qBAAOgE,YAAP,CAAoBH,OAApB;AACAA,wBAAUI,SAAV;AACD;AACF;AACD/B,aAAG0B,KAAH;AACA3C,kBAAQ,EAACsB,kBAAD,EAAR;AACD;;AAEDsB,kBAAU7D,OAAOkE,UAAP,CAAkB,YAAM;AAChCtD,kBAAQC,IAAR,CAAgB,MAAKmB,SAArB;AACA8B,sBAAY,KAAZ,EAAmBD,OAAnB,EAA4BtB,QAA5B;AACD,SAHS,EAGP,IAHO,CAAV;;AAKAL,WAAGiC,0BAAH,GAAgC,YAAM;AACpC,cAAIjC,EAAJ,EAAQ;AACN,gBAAIA,GAAGkC,kBAAH,KAA0BC,qBAAUC,QAAxC,EAAkD;AAChD/B,uBAASD,KAAT,GAAiBiC,KAAKC,GAAL,EAAjB;AACD;AACD,gBAAItC,GAAGkC,kBAAH,KAA0BC,qBAAUI,SAAxC,EAAmD;AACjDlC,uBAASC,IAAT,GAAgB+B,KAAKC,GAAL,EAAhB;AACAV,0BAAY,IAAZ,EAAkBD,OAAlB,EAA2BtB,QAA3B;AACD;AACD,gBAAIL,GAAGkC,kBAAH,KAA0BC,qBAAUK,MAAxC,EAAgD;AAC9CZ,0BAAY,KAAZ,EAAmBD,OAAnB,EAA4BtB,QAA5B;AACD;AACF;AACF,SAbD;AAcD,OA/BM,CAAP;AAgCD,KAnQ2B;;AAAA,UAqQ5BlC,WArQ4B,GAqQd;AAAA,aAAM,MAAKD,mBAAL,CAAyBC,WAAzB,EAAN;AAAA,KArQc;;AAE1B,UAAKD,mBAAL,GAA2B,IAAIuE,iBAAJ,CAAwB,EAAxB,EAA4BlF,OAA5B,CAA3B;AAF0B;AAG3B;;AAOD;;;;;;AA8BA;;;;;;;AAmCA;;;;;;;AA+DA;;;;;;;AAuCA;;;;;;;AA2BA;;;;;;;AAeA;;;;;;;;EA9NwCmF,+B;;kBAArBrF,Y","file":"index.js","sourcesContent":["\n/*!\n * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* globals window */\nimport {StatelessSparkPlugin} from '@ciscospark/spark-core';\n\nimport peerConnectionManager from '../peer-connection-manager';\nimport {ICE_STATE, MEETINGS, REACHABILITY, _ANSWER_} from '../constants';\n\nimport ReachabilityRequest from './request';\n\n/**\n * @class Reachability\n */\nexport default class Reachability extends StatelessSparkPlugin {\n  namespace = MEETINGS;\n\n  constructor(attrs, options) {\n    super({}, options);\n    this.reachabilityRequest = new ReachabilityRequest({}, options);\n  }\n\n  setup = () => {\n    this.processedClusterResults = [];\n    this.peerConnectionMap = {};\n  }\n\n  /**\n   * fetches reachability data\n   * @returns {object} reachability data\n   */\n  gatherReachability = () => {\n    this.setup();\n    // Reset reachability result to empty to ensure no stale data\n    try {\n      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify({}));\n\n      // Get clusters from Orpheus\n      return this.reachabilityRequest.getClusters()\n        .then((clusters) =>\n          // Perform Reachability Check\n          this.performReachabilityCheck(clusters)\n            .then((response) => {\n              window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(response));\n              return response;\n            }))\n        .catch((error) => {\n          console.info(`Error in calling getClusters() :${error}`);\n          return {};\n        });\n    }\n    catch (error) {\n      console.log('There was an error while accessing LocalStorage', error);\n      return {};\n    }\n  };\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {object} reachability check results\n   */\n  performReachabilityCheck = (clusterList) => {\n    if (!clusterList || !clusterList.length) {\n      return Promise.resolve({});\n    }\n\n    let localSDPList = [];\n\n    return new Promise(((resolve) => {\n      this.getLocalSDPForClusters(clusterList)\n        .then((localSDPData) => {\n          if (!localSDPData || !Object.keys(localSDPData).length || !localSDPData.localSDPList || !localSDPData.peerConnection) {\n            // TODO: handle the error condition properly and try retry\n            console.info('Local SDP is empty or has missing elements..returning.');\n            resolve({});\n          }\n\n          this.peerConnectionMap = localSDPData.peerConnection;\n          ({localSDPList} = localSDPData);\n          this.setRemoteOfferForEachCluster(localSDPList)\n            .then((response) => {\n              resolve(response);\n            });\n        })\n        .catch((error) => {\n          console.error(`Error in getLocalSDPForClusters :${error}`);\n          resolve({});\n        });\n    }));\n  };\n\n  /**\n   * sets remote offer for each clusters\n   * @param {object} localSDPList local SDP generated\n   * @returns {object} reachability check results\n   */\n  setRemoteOfferForEachCluster = (localSDPList) => {\n    const iceResult = {};\n    return new Promise((resolve) => {\n      this.reachabilityRequest.remoteSDPForClusters(localSDPList)\n        .then((remoteSDPResponse) => {\n          const remoteSDPList = remoteSDPResponse.answers;\n          if (!remoteSDPList || !remoteSDPList.length) {\n            console.info('Remote SDP is empty ');\n            this.cleanUpPeerConnections(this.peerConnectionMap);\n            resolve({});\n          }\n          remoteSDPList.forEach((remoteSdp) => {\n            const jsonObj = remoteSdp;\n            const {clusterId} = jsonObj;\n\n            if (jsonObj && jsonObj.sdp) {\n              const pc = this.peerConnectionMap[clusterId];\n\n              this.setIceCallBackHandlers(pc)\n                .then((iceStatsResult) => {\n                  iceStatsResult.clusterId = clusterId;\n                  this.processedClusterResults.push(iceStatsResult.clusterId);\n                  iceResult[iceStatsResult.clusterId] = {\n                    start: iceStatsResult.iceStats.start,\n                    stop: iceStatsResult.iceStats.stop\n                  };\n\n                  if (this.processedClusterResults.length === remoteSDPList.length) {\n                    const reachabilityResult = this.parseIceResultToReachabilityResult(iceResult);\n                    console.info(`Returning reachability result${JSON.stringify(reachabilityResult)}`);\n                    resolve(reachabilityResult);\n                  }\n                })\n                .catch((error) => {\n                  console.error(`Error setIceCallBackHandlers : ${error}`);\n                  this.cleanUpPeerConnections(this.peerConnectionMap);\n                  resolve({});\n                });\n              peerConnectionManager.setRemoteSessionDetails(pc, _ANSWER_, jsonObj.sdp);\n            }\n            else {\n              console.info(`${clusterId} : Error in getting remote sdp :Error  : `);\n              this.processedClusterResults.push(clusterId);\n              if (this.processedClusterResults.length === remoteSDPList.length) {\n                this.cleanUpPeerConnections(this.peerConnectionMap);\n                resolve({});\n              }\n            }\n          });\n        })\n        .catch((error) => {\n          console.error(`Error in remoteSDPForClusters!:${error}`);\n          this.cleanUpPeerConnections(this.peerConnectionMap);\n          resolve({});\n        });\n    });\n  }\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {object} localSDPData\n   */\n  getLocalSDPForClusters = (clusterList) => {\n    const localSDPData = {};\n    const localSDPList = [];\n    const peerConnectionMap = {};\n\n    return new Promise(((resolve, reject) => {\n      clusterList.forEach((cluster) => {\n        const clusterId = cluster;\n\n        peerConnectionManager.createOffer({receiveAudio: true, receiveVideo: false})\n          .then((peerConnection) => {\n            peerConnectionMap[clusterId] = peerConnection;\n\n            const localSDP = {\n              sdp: peerConnection.sdp,\n              clusterId\n            };\n\n            localSDPList.push(localSDP);\n\n            if (localSDPList.length === clusterList.length) {\n              localSDPData.peerConnection = peerConnectionMap;\n              localSDPData.localSDPList = localSDPList;\n              resolve(localSDPData);\n            }\n          })\n          .catch((error) => {\n            reject(new Error(`Error in getLocalSDP : ${error}`));\n            console.error(`Error in getLocalSDP : ${error}`);\n          });\n      });\n    }));\n  };\n\n  /**\n   * calculates time to establish connection\n   * @param {object} iceResult iceResults\n   * @returns {object} result\n   */\n  parseIceResultToReachabilityResult = (iceResult) => {\n    if (!iceResult || !Object.keys(iceResult).length) {\n      return {};\n    }\n    const result = {};\n    for (const clusterId of Object.keys(iceResult)) {\n      let reachability = {};\n      if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {\n        const latency = iceResult[clusterId].stop - iceResult[clusterId].start;\n        reachability = {\n          reachable: true,\n          latencyInMilliseconds: latency\n        };\n      }\n      else {\n        reachability = {reachable: false};\n      }\n      result[clusterId] = {udp: reachability};\n    }\n    return result;\n  };\n\n  /**\n   * cleans all the peerconnection\n   * @param {object} peerConnectionMap peerconnectionList\n   * @returns {object} localSDPData\n   */\n  cleanUpPeerConnections = (peerConnectionMap) => {\n    for (const key of Object.keys(peerConnectionMap)) {\n      const pc = peerConnectionMap[key];\n      if (pc) {\n        console.info(`Cleaning up peer connection created for cluster : ${key}`);\n        pc.close();\n      }\n    }\n  };\n\n  /**\n   * sets the success callback for peerconnection\n   * @param {object} pc peerconnection\n   * @returns {object} iceState\n   */\n  setIceCallBackHandlers = (pc) => {\n    let timeout = null;\n    const iceStats = {start: 0, stop: 0};\n    return new Promise(((resolve) => {\n      function iceComplete(isSuccessful, timeout, iceStats) {\n        if (isSuccessful) {\n          if (timeout) {\n            window.clearTimeout(timeout);\n            timeout = undefined;\n          }\n        }\n        pc.close();\n        resolve({iceStats});\n      }\n\n      timeout = window.setTimeout(() => {\n        console.info(`${this.clusterId} : onTimer, ice timeout!`);\n        iceComplete(false, timeout, iceStats);\n      }, 5000);\n\n      pc.oniceconnectionstatechange = () => {\n        if (pc) {\n          if (pc.iceConnectionState === ICE_STATE.CHECKING) {\n            iceStats.start = Date.now();\n          }\n          if (pc.iceConnectionState === ICE_STATE.CONNECTED) {\n            iceStats.stop = Date.now();\n            iceComplete(true, timeout, iceStats);\n          }\n          if (pc.iceConnectionState === ICE_STATE.FAILED) {\n            iceComplete(false, timeout, iceStats);\n          }\n        }\n      };\n    }));\n  };\n\n  getClusters = () => this.reachabilityRequest.getClusters()\n}\n"]}