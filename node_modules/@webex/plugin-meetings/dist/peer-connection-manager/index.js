'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _bowser = require('bowser');

var _bowser2 = _interopRequireDefault(_bowser);

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PC = {}; // https://github.com/clux/sdp-transform

/* eslint-disable */
// We need to figure out how to pass a spark logger instance to these util files

/* globals window, RTCSessionDescription */

var insertBandwidthLimit = function insertBandwidthLimit(sdpLines, index) {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser
  var limit = void 0;
  if (sdpLines[index].search(_constants.AUDIO) !== -1) {
    limit = _constants.AUDIO_BANDWIDTH_LIMIT;
  } else {
    limit = _constants.VIDEO_BANDWIDTH_LIMIT;
  }
  sdpLines.splice(index + 1, 0, _constants.SDP.B_LINE + ':' + limit);
  return sdpLines;
};

var setMaxFs = function setMaxFs(sdp) {
  // eslint-disable-next-line no-warning-comments
  // TODO convert with sdp parser, no munging
  var replaceSdp = sdp;
  var payloadTypes = sdp.match(/\na=fmtp:(\d+).*level-asymmetry-allowed=1.*/g);
  if (payloadTypes) {
    payloadTypes.forEach(function (payload) {
      replaceSdp = replaceSdp.replace(payload, payload + ';' + _constants.SDP.MAX_FS_8160);
    });
  }
  return replaceSdp;
};

var checkH264Support = function checkH264Support(sdp) {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser to read rtp.codec
  var videoPresent = sdp.match(/\nm=video.*/g);
  var h264Present = sdp.match(/\na=rtpmap:\d+\sH264.*/g);

  if (videoPresent) {
    return !!h264Present;
  }
  return true;
};

var validateSdp = function validateSdp(sdp) {
  var parsedSdp = _sdpTransform2.default.parse(sdp);

  parsedSdp.media.forEach(function (mediaLine) {
    if (mediaLine.candidates && mediaLine.candidates.length === 0) {
      console.error('iceCandidate: Ice candadate never completed');
      return false;
    }
    if (_constants.SDP.BAD_MEDIA_PORTS.includes(mediaLine.port)) {
      console.error('iceCandidate: Found invalid port number for the ice candidate');
      return false;
    }
    if (!mediaLine.icePwd || !mediaLine.iceUfrag) {
      console.error('iceCandidate: ice ufrag and password not found');
      return false;
    }
    return true;
  });
};

var limitBandwidth = function limitBandwidth(sdp) {
  // TODO convert to sdp parser
  var offerSdp = sdp;
  var sdpLines = offerSdp.split(_constants.SDP.CARRIAGE_RETURN);

  for (var i = 0; i < sdpLines.length; i += 1) {
    if (sdpLines[i].search(_constants.SDP.M_LINE) !== -1) {
      sdpLines = insertBandwidthLimit(sdpLines, i);
    }
  }
  offerSdp = sdpLines.join(_constants.SDP.CARRIAGE_RETURN);
  return offerSdp;
};

PC.iceFailListener = function (pc, fn, name) {
  if (!pc) {
    return;
  }
  pc.oniceconnectionstatechange = function () {
    switch (pc.iceConnectionState) {
      case _constants.ICE_STATE.FAILED:
      case _constants.ICE_STATE.DISCONNECTED:
        console.error(name + ' Interactive Connectivity Establishment(ICE)' + pc.iceConnectionState + '!', new Date());
        setTimeout(function () {
          switch (pc.iceConnectionState) {
            case _constants.ICE_STATE.FAILED:
            case _constants.ICE_STATE.DISCONNECTED:
              // if ice is still failed after some time, do the reconnect
              // else the browser resolves the ice failure on its own
              fn();
              break;
            default:
              break;
          }
        }, _constants.ICE_FAIL_TIMEOUT);
        break;
      default:
        break;
    }
  };
};

PC.detectFailures = function (pc, spc) {
  var reconnectFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
    console.error('Ice failed, no function to reconnect with.');
  };

  PC.iceFailListener(pc, reconnectFn, _constants.MEDIA_PEER_CONNECTION_NAME);
  PC.iceFailListener(spc, reconnectFn, _constants.SHARE_PEER_CONNECTION_NAME);
};

PC.setContentSlides = function (screenPc) {
  if (screenPc && screenPc.sdp) {
    screenPc.sdp += '' + _constants.SDP.A_CONTENT_SLIDES + _constants.SDP.CARRIAGE_RETURN;
  }
  return screenPc;
};

/**
 * handles ice trickling and establishes ICE connection onto peer connection object
 * @param {Object} pc
 * @returns {RTCPeerConnection}
 */
PC.iceCandidate = function (pc) {
  return new _promise2.default(function (resolve) {
    // TODO: we dont need timeout as we can check the api state and validate.
    var timeout = setTimeout(function () {
      pc.sdp = limitBandwidth(pc.localDescription.sdp);
      pc.sdp = setMaxFs(pc.sdp);
      pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');

      if (!validateSdp(pc.sdp)) {
        setTimeout(function () {
          resolve(pc);
        }, _constants.RETRY_TIMEOUT);
      } else {
        resolve(pc);
      }
    }, _constants.ICE_TIMEOUT);

    pc.onicecandidate = function (evt) {
      if (!evt.candidate && !pc.sdp) {
        pc.sdp = limitBandwidth(pc.localDescription.sdp);
        pc.sdp = setMaxFs(pc.sdp);
        pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');

        if (evt.candidate === null) {
          validateSdp(pc.sdp);
          clearTimeout(timeout);
          resolve(pc);
        }
      }
    };
  });
};

/**
 * swapping tracks
 * @param {Object} pc
 * @param {Object} track
 * @returns {undefined}
 */
PC.replaceTrack = function (pc, track) {
  try {
    var senders = pc.getSenders();
    if (senders.length > 0) {
      senders.forEach(function (sender) {
        if (sender.track && sender.track.kind === track.kind) {
          sender.replaceTrack(track);
        }
      });
    }
  } catch (err) {
    console.error('replaceTrack: Error while replacing Tracks ', err);
  }
};

/**
 * adding streams to mediaPeerConnection
 * @param {Object} pc
 * @param {Object} stream
 * @returns {undefined}
 */
PC.addStream = function (pc, stream) {
  console.info('addStream: adding streams to peerconnection');

  try {
    if (stream && !_bowser2.default.msedge) {
      var tracksPresent = pc.getSenders && pc.getSenders().find(function (sender) {
        return sender.track != null;
      });
      if (tracksPresent) {
        stream.getTracks().forEach(function (track) {
          PC.replaceTrack(pc, track);
        });
        return;
      }
      stream.getTracks().forEach(function (track) {
        pc.addTrack(track, stream);
      });
      // // TODO : may come back disable addTracks for chrome they are moving back to addStream
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
      //   pc.addStream(stream);
    } else if (_bowser2.default.msedge) {
      pc.addStream(stream);
    } else {
      console.error('addStream: No streams to add');
    }
  } catch (err) {
    console.error('addStream: Error while adding Stream ', err);
  }
};

/**
 * setting the remote description
 * @param {Object} pc
 * @param {String} typeStr
 * @param {String} remoteSdp
 * @returns {undefined}
 */
PC.setRemoteSessionDetails = function (pc, typeStr, remoteSdp) {
  var sharePeerConnection = pc.sharePeerConnection;

  console.info('Setting the remote description type: ' + typeStr + 'State: ' + pc.signalingState);
  var promiseSdp = [];
  var sdp = remoteSdp;

  sdp = sdp.replace(/\na=extmap.*/g, '');

  var mlines = sdp.split(_constants.SDP.M_LINE);
  if (mlines.length === 4 && sharePeerConnection) {
    sdp = '' + mlines[0] + _constants.SDP.M_LINE + mlines[1] + _constants.SDP.M_LINE + mlines[2];
    var contentSdp = '' + mlines[0] + _constants.SDP.M_LINE + mlines[3];
    promiseSdp.push(sharePeerConnection.setRemoteDescription(new window.RTCSessionDescription({
      type: typeStr,
      sdp: contentSdp
    })));
  }

  // making sure that the remoteDescription is only set when there is a answer for offer
  // or there is a offer from the server
  if (pc.signalingState === _constants.SDP.HAVE_LOCAL_OFFER || pc.signalingState === _constants.SDP.STABLE && typeStr === _constants.SDP.OFFER) {
    promiseSdp.push(pc.setRemoteDescription(new window.RTCSessionDescription({
      type: typeStr,
      sdp: sdp
    })));
  }
  return _promise2.default.all(promiseSdp).catch(function (err) {
    console.error('Error setting the remoteDescription', err);
    return _promise2.default.reject(err);
  });
};

/**
 * create offer with a valid paramater
 * @param {Object} params
 * @returns {RTCPeerConnection}
 */
PC.createOffer = function () {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  console.info('createOffer: creating a new offer');

  try {
    var pc = params.peerConnection || new window.RTCPeerConnection(_bowser2.default.firefox ? _constants.RTC_CONFIGURATION_FIREFOX : _constants.RTC_CONFIGURATION);
    if (params.streams) {
      if (Array.isArray(params.streams)) {
        PC.addStream(pc, params.streams[0]);
      } else {
        PC.addStream(pc, params.streams);
      }
    }

    var sdpConstraints = {
      offerToReceiveAudio: params.receiveAudio,
      offerToReceiveVideo: params.receiveVideo
    };

    return pc.createOffer(sdpConstraints).then(function (description) {
      return pc.setLocalDescription(description);
    }).then(function () {
      return PC.iceCandidate(pc);
    }).then(function () {
      pc.sdp = limitBandwidth(pc.localDescription.sdp);
      pc.sdp = setMaxFs(pc.sdp);
      if (!checkH264Support(pc.sdp)) {
        throw new Error('openH264 is downloading please Wait. Upload logs if not working on second try');
      }

      pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');

      return pc;
    }).catch(function (err) {
      PC.close(pc);
      throw err;
    });
  } catch (err) {
    console.error('createOffer: error while creating a offer ', err);
    throw err;
  }
};

/**
 * rollBack local description in peerconnection
 * @param {Object} pc
 * @returns {RTCPeerConnection}
 */
PC.rollBackLocalDescription = function (pc) {
  console.info('rollBackLocalDescription: rollingbacking peerconnection');

  return pc.setLocalDescription(new RTCSessionDescription({ type: _constants.SDP.ROLLBACK })).then(function () {
    return pc;
  }).catch(function (err) {
    console.error('rollBackLocalDescription: Error while setting the Local Description ', err);
    return _promise2.default.error(err);
  });
};

/**
 * @param {Object} params {
 *  offerToReceiveAudio: {Boolean} sdp constraints
 *  offerToReceiveVideo: {Boolean} sdp constraints
 *  offerSdp: {sdp}
 *  stream: {PCStream}
 * }
 * @returns {Array} [MediaSDP, ScreenSDP]
 */
PC.updatePeerConnection = function (params) {
  console.info('updatePeerConnection: updating the pc');

  var pc = params.pc,
      sharePeerConnection = params.sharePeerConnection;


  var screenConstraints = {
    offerToReceiveAudio: false,
    offerToReceiveVideo: true
  };
  var sdpConstraints = {
    offerToReceiveAudio: params.offerToReceiveAudio,
    offerToReceiveVideo: params.offerToReceiveVideo
  };

  if (pc === undefined && sharePeerConnection) {
    return PC.createAnswer({
      pc: sharePeerConnection,
      screenConstraints: screenConstraints,
      offerSdp: params.offerSdp[0]
    }).then(function (updatedScreenPc) {
      updatedScreenPc.sdp += '' + _constants.SDP.A_CONTENT_SLIDES + _constants.SDP.CARRIAGE_RETURN;
      return [updatedScreenPc.sdp];
    });
  }

  return _promise2.default.all([PC.createAnswer({
    pc: pc,
    sdpConstraints: sdpConstraints,
    offerSdp: params.offerSdp[0]
  }), PC.createAnswer({
    pc: sharePeerConnection,
    offerSdp: params.offerSdp[1],
    sdpConstraints: screenConstraints
  })]).then(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        updatedPc = _ref2[0],
        updatedScreenPc = _ref2[1];

    sharePeerConnection.sdp += '' + _constants.SDP.A_CONTENT_SLIDES + _constants.SDP.CARRIAGE_RETURN;
    return [updatedPc.sdp, updatedScreenPc.sdp];
  });
};

/**
 * @param {Object} params {
 *  pc: {Object} mediaPeerConnection
 *  sdpConstraints: {Object} sdp constraints
 * }
 * @returns {RTCPeerConnection} pc
 */
PC.createAnswer = function (params) {
  var pc = params.pc;

  // TODO: Some times to many mercury event comes at the same time
  // Need to maintain state of peerconnection

  if (pc.signalingState === 'have-remote-offer') {
    return _promise2.default.resolve(pc);
  }

  return PC.setRemoteSessionDetails(pc, 'offer', params.offerSdp).then(function () {
    return pc.createAnswer(params.sdpConstraints);
  }).then(function (answer) {
    return (
      //   if (edonusHack()) {
      //     answer.sdp = answer.sdp.replace(/recvonly.*/g, 'sendrecv');
      //   }
      pc.setLocalDescription(answer)
    );
  }).then(function () {
    return PC.iceCandidate(pc);
  }).then(function () {
    pc.sdp = limitBandwidth(pc.localDescription.sdp);
    pc.sdp = setMaxFs(pc.sdp);
    if (!checkH264Support(pc.sdp)) {
      throw new Error('openH264 is downloading please Wait. Upload logs if not working on second try');
    }

    pc.sdp = pc.sdp.replace(/\na=extmap.*/g, '');

    return pc;
  }).catch(function (err) {
    console.error('updatePeerConnection: error while updating the PC ', err);
  });
};

/**
 * shut down the peer connection
 * @param {Object} pc
 * @returns {undefined}
 */
PC.close = function (pc) {
  // pc.close() fails on firefox on network changes and gives a Dom exception
  // To avoid this we have added a try catch block.
  // Please refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1274407 for more information
  console.info('PC: close() -> closing the mediaPeerConnection');
  return _promise2.default.resolve().then(function () {
    if (pc && pc.close) {
      pc.close();
    } else {
      console.warn('Peer connection has no close');
    }
  }).catch(function (err) {
    console.error('Error Cleaning Up the PeerConnection', err);
  });
};

exports.default = PC;
//# sourceMappingURL=index.js.map
