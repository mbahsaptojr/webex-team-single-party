'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _constants = require('../constants');

var _calculator = require('../stats/calculator');

var _calculator2 = _interopRequireDefault(_calculator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * simply adds up the properties from filtered stream data
 */
var StatsAggregator = function () {
  /**
   * @private
   * @param {Object} options
   * options.format -- the format to store the stats reports as in summary form
   * options.summary -- if it comes prebuilt with another summary
   */
  function StatsAggregator() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { format: _constants.DEFAULT_TRANSFORM_KEYS, summary: {} };
    (0, _classCallCheck3.default)(this, StatsAggregator);

    this.summary = options.summary;
    if ((0, _keys3.default)(options.summary).length === 0) {
      options.format.forEach(function (key) {
        _this.summary[key] = {};
      });
    }
  }

  /**
   * @param {Array} format the keys to set up for the summary to fill in later
   * @returns {undefined}
   */


  (0, _createClass3.default)(StatsAggregator, [{
    key: 'setFormat',
    value: function setFormat(format) {
      var _this2 = this;

      this.clearSummary();
      format.forEach(function (key) {
        _this2.summary[key] = {};
      });
    }

    /**
     * @returns {Object} the aggregated summary at time of call
     */

  }, {
    key: 'get',
    value: function get() {
      return this.summary;
    }

    /**
     * reset the summary
     * @returns {undefined}
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.summary = {};
    }

    /**
     * calculate a new aggregation based on the last summary and an incoming data point
     * @param {WebRTCData} data
     * @returns {undefined}
     */

  }, {
    key: 'aggregate',
    value: function aggregate(data) {
      this.summary = _calculator2.default.aggregate(data, this.summary);
    }
  }]);
  return StatsAggregator;
}();

exports.default = StatsAggregator;
//# sourceMappingURL=aggregator.js.map
