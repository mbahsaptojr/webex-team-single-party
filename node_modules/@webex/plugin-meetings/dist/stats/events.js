'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _sparkCore = require('@ciscospark/spark-core');

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against
 * @param {String} type - local or remote
 * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX
 * @param {String} stat - the accessor to get the actual stat
 * @param {String} kind - audio or video
 * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never
 */
var operateEvent = function operateEvent(operate, type, keys, stat, kind) {
  var foundMatch = {};
  foundMatch.found = keys.some(function (key) {
    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {
      foundMatch.match = {
        type: type,
        key: key,
        data: operate[key],
        stat: stat,
        kind: kind
      };
      return true;
    }
    return false;
  });
  return foundMatch;
};

var StatsEvents = function (_StatelessSparkPlugin) {
  (0, _inherits3.default)(StatsEvents, _StatelessSparkPlugin);

  /**
   * constructs an instance
   * @param {Object} attrs
   * @param {Object} options
   */
  function StatsEvents(attrs, options) {
    (0, _classCallCheck3.default)(this, StatsEvents);

    var _this = (0, _possibleConstructorReturn3.default)(this, (StatsEvents.__proto__ || (0, _getPrototypeOf2.default)(StatsEvents)).call(this, {}, options));

    _this.namespace = _constants.MEETINGS;

    _this.sentFirstVideoBytes = undefined;
    _this.receivedFirstVideoBytes = undefined;
    _this.sentFirstAudioBytes = undefined;
    _this.receivedFirstAudioBytes = undefined;
    return _this;
  }

  /**
   * handles the first audio bytes received
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never
   */


  (0, _createClass3.default)(StatsEvents, [{
    key: 'receiveEventAudio',
    value: function receiveEventAudio(data) {
      if (data && data.data && data.data.getData()) {
        var operate = data.data.getData();
        if (operate && !this.receivedFirstAudioBytes) {
          var somethingMatched = operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.VIDEO);
          if (somethingMatched && somethingMatched.found && somethingMatched.match) {
            this.receivedFirstAudioBytes = somethingMatched.match;
            this.trigger(_constants.EVENT_TRIGGERS.STATS_UPDATE, this.receivedFirstAudioBytes);
          }
        }
      }
      return this.receivedFirstVideoBytes;
    }

    /**
     * handles the first video bytes received
     * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
     * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never
     */

  }, {
    key: 'receiveEventVideo',
    value: function receiveEventVideo(data) {
      if (data && data.data && data.data.getData()) {
        var operate = data.data.getData();
        if (operate && !this.receivedFirstVideoBytes) {
          var somethingMatched = operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.VIDEO);
          if (somethingMatched && somethingMatched.found && somethingMatched.match) {
            this.receivedFirstVideoBytes = somethingMatched.match;
            this.trigger(_constants.EVENT_TRIGGERS.STATS_UPDATE, this.receivedFirstVideoBytes);
          }
        }
      }
      return this.receivedFirstVideoBytes;
    }

    /**
     * handles the first video bytes sent
     * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
     * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never
     */

  }, {
    key: 'sendEventVideo',
    value: function sendEventVideo(data) {
      if (data && data.data && data.data.getData()) {
        var operate = data.data.getData();
        if (operate && !this.sentFirstVideoBytes) {
          var somethingMatched = operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_VIDEO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.VIDEO);
          if (somethingMatched && somethingMatched.found && somethingMatched.match) {
            this.sentFirstVideoBytes = somethingMatched.match;
            this.trigger(_constants.EVENT_TRIGGERS.STATS_UPDATE, this.sentFirstVideoBytes);
          }
        }
      }
      return this.sentFirstVideoBytes;
    }

    /**
     * handles the first audio bytes sent
     * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
     * @returns {Object} always whatever the first sentFirstAudioBytes were, in the past or if it happened now, or undefined if never
     */

  }, {
    key: 'sendEventAudio',
    value: function sendEventAudio(data) {
      if (data && data.data && data.data.getData()) {
        var operate = data.data.getData();
        if (operate && !this.sentFirstAudioBytes) {
          var somethingMatched = operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_AUDIO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.AUDIO);
          if (somethingMatched && somethingMatched.found && somethingMatched.match) {
            this.sentFirstAudioBytes = somethingMatched.match;
            this.trigger(_constants.EVENT_TRIGGERS.STATS_UPDATE, this.sentFirstAudioBytes);
          }
        }
      }
      return this.sentFirstVideoBytes;
    }

    /**
     * handles all the types of events that need to be sent when they happen from getStats API
     * @param {WebRTCData} data
     * @returns {Object}
     */

  }, {
    key: 'event',
    value: function event(data) {
      return {
        sentFirstVideoBytes: this.sendEventVideo(data),
        receivedFirstVideoBytes: this.receiveEventVideo(data),
        sentFirstAudioBytes: this.sendEventAudio(data),
        receivedFirstAudioBytes: this.receiveEventAudio(data)
      };
    }
  }]);
  return StatsEvents;
}(_sparkCore.StatelessSparkPlugin);

exports.default = StatsEvents;
//# sourceMappingURL=events.js.map
