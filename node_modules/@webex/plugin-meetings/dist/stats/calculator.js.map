{"version":3,"sources":["calculator.js"],"names":["StatsCalculator","interval","previous","updated","data","getData","length","forEach","key","stat","value","DEFAULT_EXCLUDED_STATS","includes","aggregate","summary"],"mappings":";;;;;;;;;;;;;;AAEA;;;;AAEA,IAAMA,kBAAkB,EAAxB;;AAEA;AACAA,gBAAgBC,QAAhB,GAA2B,UAACC,QAAD,EAAWC,OAAX,EAAuB;AAChD;AACA,MAAI,CAACD,QAAD,IAAa,CAACA,SAASE,IAAvB,IAA+B,CAACF,SAASE,IAAT,CAAcC,OAA9C,IAAyD,oBAAKH,SAASE,IAAT,CAAcC,OAAd,EAAL,EAA8BC,MAA9B,KAAyC,CAAtG,EAAyG;AACvG,WAAOH,OAAP;AACD;AACD,MAAMF,WAAW,EAAjB;AACA;AACA,sBAAKE,QAAQC,IAAR,CAAaC,OAAb,EAAL,EAA6BE,OAA7B,CAAqC,UAACC,GAAD,EAAS;AAC5CP,aAASO,GAAT,IAAgBP,SAASO,GAAT,IAAgBP,SAASO,GAAT,CAAhB,GAAgC,EAAhD;AACA,wBAAKL,QAAQC,IAAR,CAAaC,OAAb,GAAuBG,GAAvB,CAAL,EAAkCD,OAAlC,CAA0C,UAACE,IAAD,EAAU;AAClD,UAAIC,QAAQP,QAAQC,IAAR,CAAaC,OAAb,GAAuBG,GAAvB,EAA4BC,IAA5B,CAAZ;AACA;AACA,UAAI,wBAASC,KAAT,KAAmB,EAAEC,kCAAuBC,QAAvB,CAAgCH,IAAhC,KAAyCC,UAAU,CAArD,CAAvB,EAAgF;AAC9E;AACA,YAAI,CAACR,SAASE,IAAT,CAAcC,OAAd,GAAwBG,GAAxB,CAAD,IAAiC,CAACN,SAASE,IAAT,CAAcC,OAAd,GAAwBG,GAAxB,EAA6BC,IAA7B,CAAtC,EAA0E;AACxER,mBAASO,GAAT,EAAcC,IAAd,IAAsBC,KAAtB;AACD;AACD;AAHA,aAIK;AACHA,qBAASR,SAASE,IAAT,CAAcC,OAAd,GAAwBG,GAAxB,EAA6BC,IAA7B,CAAT;AACAR,qBAASO,GAAT,EAAcC,IAAd,IAAsBC,KAAtB;AACD;AACF;AACF,KAdD;AAeD,GAjBD;AAkBA,SAAOT,QAAP;AACD,CA1BD;;AA4BA;AACAD,gBAAgBa,SAAhB,GAA4B,UAACT,IAAD,EAAOU,OAAP,EAAmB;AAC7C,MAAMD,YAAYC,OAAlB;AACA;AACA,sBAAKV,KAAKA,IAAL,CAAUC,OAAV,EAAL,EAA0BE,OAA1B,CAAkC,UAACC,GAAD,EAAS;AACzC,wBAAKJ,KAAKA,IAAL,CAAUC,OAAV,GAAoBG,GAApB,CAAL,EAA+BD,OAA/B,CAAuC,UAACE,IAAD,EAAU;AAC/C,UAAMC,QAAQN,KAAKA,IAAL,CAAUC,OAAV,GAAoBG,GAApB,EAAyBC,IAAzB,CAAd;AACA;AACA,UAAI,wBAASC,KAAT,KAAmB,EAAEC,kCAAuBC,QAAvB,CAAgCH,IAAhC,KAAyCC,UAAU,CAArD,CAAvB,EAAgF;AAC9E;AACA,YAAIG,UAAUL,GAAV,EAAeC,IAAf,CAAJ,EAA0B;AACxBI,oBAAUL,GAAV,EAAeC,IAAf,KAAwBC,KAAxB;AACD;AACD;AAHA,aAIK;AACHG,sBAAUL,GAAV,EAAeC,IAAf,IAAuBC,KAAvB;AACD;AACF;AACF,KAbD;AAcD,GAfD;AAgBA,SAAOG,SAAP;AACD,CApBD;;kBAsBeb,e","file":"calculator.js","sourcesContent":["import {keys, isFinite} from 'lodash';\n\nimport {DEFAULT_EXCLUDED_STATS} from '../constants';\n\nconst StatsCalculator = {};\n\n// calculate an interval of values between 2 data points, using updated as the \"latest\" so updated - previous = interval\nStatsCalculator.interval = (previous, updated) => {\n  // if there was no previous, just take the updated\n  if (!previous || !previous.data || !previous.data.getData || keys(previous.data.getData()).length === 0) {\n    return updated;\n  }\n  const interval = {};\n  // get inside the data from the filtered report\n  keys(updated.data.getData()).forEach((key) => {\n    interval[key] = interval[key] ? interval[key] : {};\n    keys(updated.data.getData()[key]).forEach((stat) => {\n      let value = updated.data.getData()[key][stat];\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was nothing there before, just return the updated data\n        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {\n          interval[key][stat] = value;\n        }\n        // subract and store\n        else {\n          value -= previous.data.getData()[key][stat];\n          interval[key][stat] = value;\n        }\n      }\n    });\n  });\n  return interval;\n};\n\n// calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data\nStatsCalculator.aggregate = (data, summary) => {\n  const aggregate = summary;\n  // get inside the data from the filtered report\n  keys(data.data.getData()).forEach((key) => {\n    keys(data.data.getData()[key]).forEach((stat) => {\n      const value = data.data.getData()[key][stat];\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was something there before, add to that value\n        if (aggregate[key][stat]) {\n          aggregate[key][stat] += value;\n        }\n        // set up the value as the new data point\n        else {\n          aggregate[key][stat] = value;\n        }\n      }\n    });\n  });\n  return aggregate;\n};\n\nexport default StatsCalculator;\n"]}