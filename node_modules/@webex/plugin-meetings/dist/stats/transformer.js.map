{"version":3,"sources":["transformer.js"],"names":["StatsTransformer","simplify","stat","DEFAULT_TRANSFORM_REGEX","key","value","regex","test","id","profiler","type","includes","toLowerCase","decider","selector","parse","report","target","forEach","size","DEFAULT_GET_STATS_FILTER","types","convert","parsed","options","simplifyFn","transform","undefined","data"],"mappings":";;;;;;;;;;;;;;;;;;AAEA;;;;AAEA,IAAMA,mBAAmB,EAAzB;;AAEA;AACAA,iBAAiBC,QAAjB,GAA4B,UAACC,IAAD;AAAA,SAAU,oBAAK,oBAAKC,kCAAL,CAAL,EAAoC,UAACC,GAAD,EAAS;AACjF;AACA,QAAIC,QAASF,mCAAwBC,GAAxB,EAA6BE,KAA7B,CAAmCC,IAAnC,CAAwCL,KAAKM,EAA7C,IAAmDJ,GAAnD,GAAyD,KAAtE;AACA,QAAIC,KAAJ,EAAW;AACT;AACA,UAAIF,mCAAwBE,KAAxB,EAA+BI,QAAnC,EAA6C;AAC3C,YAAI,EAAGP,KAAKC,mCAAwBE,KAAxB,EAA+BI,QAA/B,CAAwCC,IAA7C,EAAmDC,QAAnD,CAA4DR,mCAAwBE,KAAxB,EAA+BI,QAA/B,CAAwCJ,KAApG,CAAD,IACFA,MAAMO,WAAN,GAAoBD,QAApB,CAA6BR,mCAAwBE,KAAxB,EAA+BI,QAA/B,CAAwCJ,KAArE,CADA,CAAJ,EACmF;AACjFA,kBAAQ,KAAR;AACA,iBAAOA,KAAP;AACD;AACF;AACD;AACA,UAAIF,mCAAwBE,KAAxB,EAA+BQ,OAAnC,EAA4C;AAC1C,YAAIX,KAAKC,mCAAwBE,KAAxB,EAA+BQ,OAApC,MAAiDV,mCAAwBE,KAAxB,EAA+BS,QAApF,EAA8F;AAC5FT,kBAAQ,KAAR;AACA,iBAAOA,KAAP;AACD;AACF;AACF;AACD,WAAOA,KAAP;AACD,GArBqC,CAAV;AAAA,CAA5B;;AAuBA;AACAL,iBAAiBe,KAAjB,GAAyB,UAACC,MAAD,EAAY;AACnC,MAAMC,SAAS,EAAf;AACA;AACA;AACA,MAAID,UAAUA,OAAOE,OAAjB,IAA4BF,OAAOG,IAAP,GAAc,CAA9C,EAAiD;AAC/CH,WAAOE,OAAP,CAAe,UAAChB,IAAD,EAAU;AACvB;AACA,UAAIA,QAAQA,KAAKQ,IAAjB,EAAuB;AACrB;AACA,YAAIU,oCAAyBC,KAAzB,CAA+BV,QAA/B,CAAwCT,KAAKQ,IAA7C,CAAJ,EAAwD;AACtD;AACAO,iBAAOf,KAAKM,EAAZ,IAAkBN,IAAlB;AACD;AACF;AACF,KATD;AAUD;AACD,SAAOe,MAAP;AACD,CAjBD;;AAmBAjB,iBAAiBsB,OAAjB,GAA2B,UAACC,MAAD,EAASC,OAAT,EAAqB;AAC9C;AACA,MAAIA,QAAQC,UAAZ,EAAwB;AACtB,WAAOD,QAAQC,UAAR,CAAmBF,MAAnB,CAAP;AACD;AACD;AACA,MAAMN,SAAS,EAAf;AACA,yBAAQM,MAAR,EAAgB,UAACrB,IAAD,EAAU;AACxB,QAAME,MAAMJ,iBAAiBC,QAAjB,CAA0BC,IAA1B,CAAZ;AACA,QAAIE,GAAJ,EAAS;AACPa,aAAOb,GAAP,IAAcF,IAAd;AACD;AACF,GALD;AAMA,SAAOe,MAAP;AACD,CAdD;;AAgBA;AACAjB,iBAAiB0B,SAAjB,GAA6B,UAACV,MAAD,EAA+C;AAAA,MAAtCQ,OAAsC,uEAA5B,EAACC,YAAYE,SAAb,EAA4B;;AAC1E,MAAIC,aAAJ;AACA;AACA,MAAML,SAASvB,iBAAiBe,KAAjB,CAAuBC,MAAvB,CAAf;AACA;AACA,MAAIb,kCAAJ,EAA6B;AAC3ByB,WAAO5B,iBAAiBsB,OAAjB,CAAyBC,MAAzB,EAAiCC,OAAjC,CAAP;AACD,GAFD,MAGK;AACHI,WAAOL,MAAP;AACD;AACD,SAAOK,IAAP;AACD,CAZD;kBAae5B,gB","file":"transformer.js","sourcesContent":["import {keys, find, forEach} from 'lodash';\n\nimport {DEFAULT_TRANSFORM_REGEX, DEFAULT_GET_STATS_FILTER} from '../constants';\n\nconst StatsTransformer = {};\n\n// convert the ids from the parsed stats objects into understandable keys\nStatsTransformer.simplify = (stat) => find(keys(DEFAULT_TRANSFORM_REGEX), (key) => {\n  // no other parameters necessary besides id\n  let value = (DEFAULT_TRANSFORM_REGEX[key].regex.test(stat.id) ? key : false);\n  if (value) {\n    // some types need to check against a type field as well\n    if (DEFAULT_TRANSFORM_REGEX[value].profiler) {\n      if (!((stat[DEFAULT_TRANSFORM_REGEX[value].profiler.type].includes(DEFAULT_TRANSFORM_REGEX[value].profiler.value))\n      && (value.toLowerCase().includes(DEFAULT_TRANSFORM_REGEX[value].profiler.value)))) {\n        value = false;\n        return value;\n      }\n    }\n    // others were included but have a value that exclude them from the list because of duplicates that weren't chosen\n    if (DEFAULT_TRANSFORM_REGEX[value].decider) {\n      if (stat[DEFAULT_TRANSFORM_REGEX[value].decider] !== DEFAULT_TRANSFORM_REGEX[value].selector) {\n        value = false;\n        return value;\n      }\n    }\n  }\n  return value;\n});\n\n// parse the RTCStatsReport, extracting only the data we care about\nStatsTransformer.parse = (report) => {\n  const target = {};\n  // from the stats object\n  // get the rtc stats report\n  if (report && report.forEach && report.size > 0) {\n    report.forEach((stat) => {\n      // each report has internal data\n      if (stat && stat.type) {\n        // pull only certain types\n        if (DEFAULT_GET_STATS_FILTER.types.includes(stat.type)) {\n          // insert into the target the statistic mapped to it's statical id\n          target[stat.id] = stat;\n        }\n      }\n    });\n  }\n  return target;\n};\n\nStatsTransformer.convert = (parsed, options) => {\n  // supply your own simplification function (rather than id as the key)\n  if (options.simplifyFn) {\n    return options.simplifyFn(parsed);\n  }\n  // else use ours that stores things like rtcOutAudio, rtpInVideo, etc\n  const target = {};\n  forEach(parsed, (stat) => {\n    const key = StatsTransformer.simplify(stat);\n    if (key) {\n      target[key] = stat;\n    }\n  });\n  return target;\n};\n\n// transform the RTCStatsReport into a much more readable, processable format\nStatsTransformer.transform = (report, options = {simplifyFn: undefined}) => {\n  let data;\n  // first parse it and cut out not necessary data\n  const parsed = StatsTransformer.parse(report);\n  // either convert the data or store each stat with it's id mapped as the key to the stat object itself\n  if (DEFAULT_TRANSFORM_REGEX) {\n    data = StatsTransformer.convert(parsed, options);\n  }\n  else {\n    data = parsed;\n  }\n  return data;\n};\nexport default StatsTransformer;\n"]}