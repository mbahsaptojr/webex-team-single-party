{"version":3,"sources":["stream.js"],"names":["emittersByPc","pcsByEmitter","emittersByStream","timersByEmitter","schedule","emitter","timer","pc","get","getStats","then","stats","emit","_DATA_","signalingState","_CLOSED_","connectionState","catch","err","_ERROR_","DEFAULT_STATS_INTERVAL","set","StatsStream","objectMode","has","EventEmitter","once","data","isPaused","push","Readable"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;;AAEA;;;;AAEA,IAAMA,eAAe,uBAArB;AACA,IAAMC,eAAe,uBAArB;AACA,IAAMC,mBAAmB,uBAAzB;AACA,IAAMC,kBAAkB,uBAAxB;;AAEA;;;;;;;AAOA,IAAMC,WAAW,SAAXA,QAAW,CAACC,OAAD,EAAa;AAC5B,MAAMC,QAAQ,kCAAe,YAAM;AACjC,QAAMC,KAAKN,aAAaO,GAAb,CAAiBH,OAAjB,CAAX;AACA,QAAIE,EAAJ,EAAQ;AACNA,SAAGE,QAAH,GACGC,IADH,CACQ,UAACC,KAAD,EAAW;AACfN,gBAAQO,IAAR,CAAaC,iBAAb,EAAqBF,KAArB;AACA;AACA;AACA;AACA;AACA,YAAI,EAAEJ,GAAGO,cAAH,KAAsBC,mBAAtB,IAAkCR,GAAGS,eAAH,KAAuBD,mBAA3D,CAAJ,EAA0E;AACxEX,mBAASC,OAAT;AACD;AACF,OAVH,EAWGY,KAXH,CAWS,UAACC,GAAD,EAAS;AACdb,gBAAQO,IAAR,CAAaO,kBAAb,EAAsBD,GAAtB;AACD,OAbH;AAcD;AACF,GAlBa,EAkBXE,iCAlBW,CAAd;;AAoBAjB,kBAAgBkB,GAAhB,CAAoBhB,OAApB,EAA6BC,KAA7B;AACD,CAtBD;;AAwBA;;;;;IAIqBgB,W;;;AACnB;;;;AAIA,uBAAYf,EAAZ,EAAgB;AAAA;;AAAA,gJACR,EAACgB,YAAY,IAAb,EADQ;;AAGd,QAAI,CAACvB,aAAawB,GAAb,CAAiBjB,EAAjB,CAAL,EAA2B;AACzBP,mBAAaqB,GAAb,CAAiBd,EAAjB,EAAqB,IAAIkB,oBAAJ,EAArB;AACD;AACD,QAAMpB,UAAUL,aAAaQ,GAAb,CAAiBD,EAAjB,CAAhB;;AAEA,QAAI,CAACL,iBAAiBsB,GAAjB,OAAL,EAAiC;AAC/BtB,uBAAiBmB,GAAjB,QAA2BhB,OAA3B;AACD;AACD,QAAI,CAACJ,aAAauB,GAAb,CAAiBnB,OAAjB,CAAL,EAAgC;AAC9BJ,mBAAaoB,GAAb,CAAiBhB,OAAjB,EAA0BE,EAA1B;AACD;;AAEDF,YAAQqB,IAAR,CAAaP,kBAAb,EAAsB,UAACD,GAAD,EAAS;AAC7B,YAAKN,IAAL,CAAUO,kBAAV,EAAmBD,GAAnB;AACD,KAFD;AAfc;AAkBf;;AAED;;;;;;;;;4BAKQ;AAAA;;AACN,UAAMb,UAAUH,iBAAiBM,GAAjB,CAAqB,IAArB,CAAhB;;AAEAH,cAAQqB,IAAR,CAAab,iBAAb,EAAqB,UAACc,IAAD,EAAU;AAC7B,YAAI,CAAC,OAAKC,QAAL,EAAL,EAAsB;AACpB,iBAAKC,IAAL,CAAUF,IAAV;AACD;AACF,OAJD;;AAMA,UAAI,CAACxB,gBAAgBqB,GAAhB,CAAoBnB,OAApB,CAAL,EAAmC;AACjCD,iBAASC,OAAT;AACD;AACF;;;EA1CsCyB,gB;;kBAApBR,W","file":"stream.js","sourcesContent":["import {Readable} from 'stream';\nimport {EventEmitter} from 'events';\n\nimport {safeSetTimeout} from '@ciscospark/common-timers';\n\nimport {_ERROR_, _DATA_, _CLOSED_, DEFAULT_STATS_INTERVAL} from '../constants';\n\nconst emittersByPc = new WeakMap();\nconst pcsByEmitter = new WeakMap();\nconst emittersByStream = new WeakMap();\nconst timersByEmitter = new WeakMap();\n\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @private\n * @returns {undefined}\n */\nconst schedule = (emitter) => {\n  const timer = safeSetTimeout(() => {\n    const pc = pcsByEmitter.get(emitter);\n    if (pc) {\n      pc.getStats()\n        .then((stats) => {\n          emitter.emit(_DATA_, stats);\n          // TODO: Remove on 1.0 spec adoption\n          // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n          // enum according to spec, but at time of writing, was still implemented\n          // in the {@link RTCSignalingState} enum.\n          if (!(pc.signalingState === _CLOSED_ || pc.connectionState === _CLOSED_)) {\n            schedule(emitter);\n          }\n        })\n        .catch((err) => {\n          emitter.emit(_ERROR_, err);\n        });\n    }\n  }, DEFAULT_STATS_INTERVAL);\n\n  timersByEmitter.set(emitter, timer);\n};\n\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}\n * {@link RTCStatsReport}\n */\nexport default class StatsStream extends Readable {\n  /**\n   * @private\n   * @param {RTCPeerConnection} pc\n   */\n  constructor(pc) {\n    super({objectMode: true});\n\n    if (!emittersByPc.has(pc)) {\n      emittersByPc.set(pc, new EventEmitter());\n    }\n    const emitter = emittersByPc.get(pc);\n\n    if (!emittersByStream.has(this)) {\n      emittersByStream.set(this, emitter);\n    }\n    if (!pcsByEmitter.has(emitter)) {\n      pcsByEmitter.set(emitter, pc);\n    }\n\n    emitter.once(_ERROR_, (err) => {\n      this.emit(_ERROR_, err);\n    });\n  }\n\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n  _read() {\n    const emitter = emittersByStream.get(this);\n\n    emitter.once(_DATA_, (data) => {\n      if (!this.isPaused()) {\n        this.push(data);\n      }\n    });\n\n    if (!timersByEmitter.has(emitter)) {\n      schedule(emitter);\n    }\n  }\n}\n\n"]}