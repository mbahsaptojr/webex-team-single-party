{"version":3,"sources":["events.js"],"names":["operateEvent","operate","type","keys","stat","kind","foundMatch","found","some","key","match","data","StatsEvents","attrs","options","namespace","MEETINGS","sentFirstVideoBytes","undefined","receivedFirstVideoBytes","sentFirstAudioBytes","receivedFirstAudioBytes","getData","somethingMatched","EVENT_TYPES","REMOTE","DEFAULT_EVENT_AUDIO_RECEIVE_KEYS","EVENT_STATS_MAP","BYTES_RECEIVED","VIDEO","trigger","EVENT_TRIGGERS","STATS_UPDATE","DEFAULT_EVENT_VIDEO_RECEIVE_KEYS","LOCAL","DEFAULT_EVENT_VIDEO_SEND_KEYS","BYTES_SENT","DEFAULT_EVENT_AUDIO_SEND_KEYS","AUDIO","sendEventVideo","receiveEventVideo","sendEventAudio","receiveEventAudio","StatelessSparkPlugin"],"mappings":"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","file":"events.js","sourcesContent":["import {StatelessSparkPlugin} from '@ciscospark/spark-core';\n\nimport {DEFAULT_EVENT_VIDEO_SEND_KEYS, DEFAULT_EVENT_AUDIO_SEND_KEYS, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_TYPES, EVENT_TRIGGERS, EVENT_STATS_MAP, MEETINGS, AUDIO, VIDEO} from '../constants';\n\n/**\n * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against\n * @param {String} type - local or remote\n * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX\n * @param {String} stat - the accessor to get the actual stat\n * @param {String} kind - audio or video\n * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n */\nconst operateEvent = (operate, type, keys, stat, kind) => {\n  const foundMatch = {};\n  foundMatch.found = keys.some((key) => {\n    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {\n      foundMatch.match = {\n        type,\n        key,\n        data: operate[key],\n        stat,\n        kind\n      };\n      return true;\n    }\n    return false;\n  });\n  return foundMatch;\n};\n\nexport default class StatsEvents extends StatelessSparkPlugin {\n  namespace = MEETINGS;\n\n  /**\n   * constructs an instance\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n  constructor(attrs, options) {\n    super({}, options);\n    this.sentFirstVideoBytes = undefined;\n    this.receivedFirstVideoBytes = undefined;\n    this.sentFirstAudioBytes = undefined;\n    this.receivedFirstAudioBytes = undefined;\n  }\n\n  /**\n   * handles the first audio bytes received\n   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against\n   * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never\n   */\n  receiveEventAudio(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n      if (operate && !this.receivedFirstAudioBytes) {\n        const somethingMatched = operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO);\n        if (somethingMatched && somethingMatched.found && somethingMatched.match) {\n          this.receivedFirstAudioBytes = somethingMatched.match;\n          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.receivedFirstAudioBytes);\n        }\n      }\n    }\n    return this.receivedFirstVideoBytes;\n  }\n\n  /**\n   * handles the first video bytes received\n   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against\n   * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never\n   */\n  receiveEventVideo(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n      if (operate && !this.receivedFirstVideoBytes) {\n        const somethingMatched = operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO);\n        if (somethingMatched && somethingMatched.found && somethingMatched.match) {\n          this.receivedFirstVideoBytes = somethingMatched.match;\n          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.receivedFirstVideoBytes);\n        }\n      }\n    }\n    return this.receivedFirstVideoBytes;\n  }\n\n  /**\n   * handles the first video bytes sent\n   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against\n   * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n   */\n  sendEventVideo(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n      if (operate && !this.sentFirstVideoBytes) {\n        const somethingMatched = operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_VIDEO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, VIDEO);\n        if (somethingMatched && somethingMatched.found && somethingMatched.match) {\n          this.sentFirstVideoBytes = somethingMatched.match;\n          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.sentFirstVideoBytes);\n        }\n      }\n    }\n    return this.sentFirstVideoBytes;\n  }\n\n  /**\n   * handles the first audio bytes sent\n   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against\n   * @returns {Object} always whatever the first sentFirstAudioBytes were, in the past or if it happened now, or undefined if never\n   */\n  sendEventAudio(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n      if (operate && !this.sentFirstAudioBytes) {\n        const somethingMatched = operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_AUDIO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, AUDIO);\n        if (somethingMatched && somethingMatched.found && somethingMatched.match) {\n          this.sentFirstAudioBytes = somethingMatched.match;\n          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.sentFirstAudioBytes);\n        }\n      }\n    }\n    return this.sentFirstVideoBytes;\n  }\n\n  /**\n   * handles all the types of events that need to be sent when they happen from getStats API\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  event(data) {\n    return {\n      sentFirstVideoBytes: this.sendEventVideo(data),\n      receivedFirstVideoBytes: this.receiveEventVideo(data),\n      sentFirstAudioBytes: this.sendEventAudio(data),\n      receivedFirstAudioBytes: this.receiveEventAudio(data)\n    };\n  }\n}\n"]}