{"version":3,"sources":["index.js"],"names":["MeetingInfo","attrs","options","namespace","MEETINGS","meetingInfoRequest","MeetingInfoRequest","fetchMeetingInfo","then","info","setMeetingInfo","id","catch","error","reject","destination","type","MeetingInfoUtil","generateOptions","conversationServiceUrl","spark","internal","device","services","fetchInfoOptions","requestFetchInfo","MEETING_LINK","convertLinkToSip","SIP_URI","MeetingInfoCollection","get","set","StatelessSparkPlugin"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAEA;;AAEA;;;;AACA;;;;AACA;;;;;;AAEA;;;IAGqBA,W;;;AAGnB;;;;;AAKA,uBAAYC,KAAZ,EAAmBC,OAAnB,EAA4B;AAAA;;AAAA,gJACpB,EADoB,EAChBA,OADgB;;AAAA,UAP5BC,SAO4B,GAPhBC,mBAOgB;;AAE1B,UAAKC,kBAAL,GAA0B,IAAIC,iBAAJ,CAAuB,EAAvB,EAA2BJ,OAA3B,CAA1B;AAF0B;AAG3B;;AAED;;;;;;;;;;;AAmBA;;;;;;qCAMiBA,O,EAAS;AACxB,aAAO,KAAKG,kBAAL,CAAwBE,gBAAxB,CAAyCL,OAAzC,EAAkDM,IAAlD,CAAuD,UAACC,IAAD,EAAU;AACtET,oBAAYU,cAAZ,CAA2BD,KAAKE,EAAhC,EAAoCF,IAApC;AACA,eAAOA,IAAP;AACD,OAHM,EAGJG,KAHI,CAGE,UAACC,KAAD;AAAA,eAAW,kBAAQC,MAAR,CAAeD,KAAf,CAAX;AAAA,OAHF,CAAP;AAID;;AAED;;;;;;;;;;qCAOiBE,W,EAAaC,I,EAAM;AAClC,aAAOC,eAAgBC,eAAhB,CAAgC;AACrCH,gCADqC;AAErCC,kBAFqC;AAGrCG,gCAAwB,KAAKC,KAAL,CAAWC,QAAX,CAAoBC,MAApB,CAA2BC,QAA3B,CAAoCJ;AAHvB,OAAhC,CAAP;AAKD;;AAED;;;;;;;;;;qCAOiBJ,W,EAA0B;AAAA;;AAAA,UAAbC,IAAa,uEAAN,IAAM;;AACzC,UAAMd,UAAU,KAAKsB,gBAAL,CAAsBT,WAAtB,EAAmCC,IAAnC,CAAhB;AACA;AACA,aAAO,KAAKS,gBAAL,CAAsBvB,OAAtB,EAA+BU,KAA/B,CAAqC,UAACC,KAAD,EAAW;AACrD;AACA,YAAIX,QAAQc,IAAR,KAAiBU,uBAArB,EAAmC;AACjC;AACA,iBAAO,OAAKD,gBAAL,CAAsB,OAAKD,gBAAL,CAAsBP,eAAgBU,gBAAhB,CAAiCZ,WAAjC,CAAtB,EAAqEa,kBAArE,CAAtB,CAAP;AACD;AACD,eAAO,kBAAQd,MAAR,CAAeD,KAAf,CAAP;AACD,OAPM,CAAP;AAQD;;;mCA5DqBF,E,EAAI;AACxB,aAAOkB,qBAAsBC,GAAtB,CAA0BnB,EAA1B,CAAP;AACD;;AAED;;;;;;;;;mCAMsBA,E,EAAIF,I,EAAM;AAC9BoB,2BAAsBE,GAAtB,CAA0BpB,EAA1B,EAA8BF,IAA9B;AACD;;;EA9BsCuB,+B,GAfzC;;;;kBAeqBhC,W","file":"index.js","sourcesContent":["/*!\n * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {StatelessSparkPlugin} from '@ciscospark/spark-core';\n\nimport {MEETINGS, MEETING_LINK, SIP_URI} from '../constants';\n\nimport MeetingInfoCollection from './collection';\nimport MeetingInfoRequest from './request';\nimport MeetingInfoUtil from './util';\n\n/**\n * @class MeetingInfo\n */\nexport default class MeetingInfo extends StatelessSparkPlugin {\n  namespace = MEETINGS;\n\n  /**\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n  constructor(attrs, options) {\n    super({}, options);\n    this.meetingInfoRequest = new MeetingInfoRequest({}, options);\n  }\n\n  /**\n   * @param {string} id\n   * @returns {object}\n   * @memberof MeetingInfo\n   */\n  static getMeetingInfo(id) {\n    return MeetingInfoCollection.get(id);\n  }\n\n  /**\n   * @param {string} id\n   * @param {object} info\n   * @returns {null}\n   * @memberof MeetingInfo\n   */\n  static setMeetingInfo(id, info) {\n    MeetingInfoCollection.set(id, info);\n  }\n\n  /**\n   * Helper to make the actual MeetingInfo request and set the meetingInfo if successful, else reject\n   * @param {Object} options\n   * @returns {Promise}\n   * @private\n   */\n  requestFetchInfo(options) {\n    return this.meetingInfoRequest.fetchMeetingInfo(options).then((info) => {\n      MeetingInfo.setMeetingInfo(info.id, info);\n      return info;\n    }).catch((error) => Promise.reject(error));\n  }\n\n  /**\n   * Helper to generate the options for the MeetingInfo request\n   * @param {String} destination\n   * @param {String} type\n   * @returns {Object}\n   * @private\n   */\n  fetchInfoOptions(destination, type) {\n    return MeetingInfoUtil.generateOptions({\n      destination,\n      type,\n      conversationServiceUrl: this.spark.internal.device.services.conversationServiceUrl\n    });\n  }\n\n  /**\n   * Fetches meeting info from the server\n   * @param {String} destination one of many different types of destinations to look up info for\n   * @param {String} type optional type to match up with the destination value\n   * @returns {Promise} returns a meeting info object\n   * @public\n   */\n  fetchMeetingInfo(destination, type = null) {\n    const options = this.fetchInfoOptions(destination, type);\n    // fetch meeting info\n    return this.requestFetchInfo(options).catch((error) => {\n      // if it failed the first time as meeting link\n      if (options.type === MEETING_LINK) {\n        // convert the meeting link to sip URI and retry\n        return this.requestFetchInfo(this.fetchInfoOptions(MeetingInfoUtil.convertLinkToSip(destination), SIP_URI));\n      }\n      return Promise.reject(error);\n    });\n  }\n}\n"]}