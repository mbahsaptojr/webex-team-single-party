{"version":3,"sources":["util.js"],"names":["MeetingInfoUtil","getParsedUrl","link","parsedUrl","url","parse","protocol","HTTPS_PROTOCOL","error","console","isMeetingLink","value","hostNameBool","hostname","includes","WEBEX_DOT_COM","pathNameBool","pathname","MEET","MEET_M","JOIN","convertLinkToSip","user","userIndex","lastIndexOf","substring","company","companyIndex","replace","WWW_DOT","isSipUri","sipString","sipUri","DIALER_REGEX","SIP_ADDRESS","exec","isPhoneNumber","phoneNumber","isValidNumber","PHONE_NUMBER","test","generateOptions","from","destination","type","conversationServiceUrl","options","MEETING_LINK","SIP_URI","CONVERSATION_URL","CONVERSATIONS","getResourceUrl","resource","LOCI","MEETINGINFO","method","GET","PERSONAL_ROOM","MEETING_ID","TYPE","USE_URI_LOOKUP_FALSE","PUT","LOCUS_ID","getRequestParams","resourceOptions","api","requestParams","concat","ALTERNATE_REDIRECT_TRUE","body","lookupType","alternateRedirect","getMeetingInfoAPIFormat"],"mappings":"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","file":"util.js","sourcesContent":["import btoa from 'btoa';\nimport url from 'url';\n\nimport {\n  SIP_URI,\n  PERSONAL_ROOM,\n  MEETING_ID,\n  CONVERSATION_URL,\n  CONVERSATIONS,\n  LOCUS_ID,\n  MEETING_LINK,\n  GET,\n  PUT,\n  USE_URI_LOOKUP_FALSE,\n  TYPE,\n  LOCI,\n  MEETINGINFO,\n  ALTERNATE_REDIRECT_TRUE,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  WWW_DOT,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL\n} from '../constants';\n\nconst MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n    return parsedUrl;\n  }\n  catch (error) {\n    console.error(error);\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(`/${MEET}`) || parsedUrl.pathname.includes(`/${MEET_M}`) || parsedUrl.pathname.includes(`/${JOIN}`));\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.convertLinkToSip = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  if (!parsedUrl) {\n    return null;\n  }\n  let user;\n  if (parsedUrl.pathname) {\n    const userIndex = parsedUrl.pathname.lastIndexOf('/');\n    user = parsedUrl.pathname.substring(userIndex + 1);\n  }\n  if (!user) {\n    return null;\n  }\n  let company;\n  if (parsedUrl.hostname) {\n    const companyIndex = parsedUrl.hostname.lastIndexOf(`.${WEBEX_DOT_COM}`);\n    company = parsedUrl.hostname.substring(0, companyIndex).replace(WWW_DOT, '');\n  }\n  if (!company) {\n    return null;\n  }\n  return `${user}@${company}.${WEBEX_DOT_COM}`;\n};\n\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n  return isValidNumber;\n};\n\nMeetingInfoUtil.generateOptions = (from) => {\n  const {destination, type, conversationServiceUrl} = from;\n  if (type) {\n    return {\n      destination,\n      type\n    };\n  }\n  const options = {};\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    options.type = MEETING_LINK;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = SIP_URI;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = SIP_URI;\n    options.destination = destination;\n  }\n  else {\n    options.type = CONVERSATION_URL;\n    options.destination = `${conversationServiceUrl}/${CONVERSATIONS}/${destination}`;\n  }\n  return options;\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} value ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getResourceUrl = (type, value) => {\n  let resource = `/${LOCI}/${MEETINGINFO}`;\n  let method = GET;\n  switch (type) {\n    case SIP_URI:\n    case PERSONAL_ROOM:\n    case MEETING_ID:\n      resource = `/${LOCI}/${MEETINGINFO}/${value}?${TYPE}=${type}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    case CONVERSATION_URL:\n      method = PUT;\n      break;\n    case LOCUS_ID:\n      resource = `/${LOCI}/${value}/${MEETINGINFO}`;\n      method = PUT;\n      break;\n    case MEETING_LINK:\n      resource = `$/${LOCI}/${MEETINGINFO}/${btoa(value)}?${TYPE}=${MEETING_LINK}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    default:\n  }\n  return {\n    resource,\n    method\n  };\n};\n\nMeetingInfoUtil.getRequestParams = (resourceOptions, type, value, api) => {\n  const requestParams = {\n    method: resourceOptions.method,\n    api,\n    resource: resourceOptions.resource\n  };\n  if (resourceOptions.method === GET) {\n    // for handling URL redirections\n    requestParams.resource = requestParams.resource.concat(`&${ALTERNATE_REDIRECT_TRUE}`);\n  }\n  else if (type !== LOCUS_ID) {\n    // locus id check is a PUT not sure why\n    requestParams.body = {\n      value,\n      lookupType: type,\n      alternateRedirect: true\n    };\n  }\n  return requestParams;\n};\n\nMeetingInfoUtil.getMeetingInfoAPIFormat = (options) => ({\n  type: options.type,\n  value: options.destination\n});\n\nexport default MeetingInfoUtil;\n"]}