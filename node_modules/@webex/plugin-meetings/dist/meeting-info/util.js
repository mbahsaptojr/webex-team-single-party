'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _btoa = require('btoa');

var _btoa2 = _interopRequireDefault(_btoa);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MeetingInfoUtil = {};

MeetingInfoUtil.getParsedUrl = function (link) {
  try {
    var parsedUrl = _url2.default.parse(link);
    if (!parsedUrl) {
      return false;
    }
    // hack for links such as <company>.webex.com/meet/<user> without a protocol
    if (!parsedUrl.protocol) {
      parsedUrl = _url2.default.parse('' + _constants.HTTPS_PROTOCOL + link);
    }
    return parsedUrl;
  } catch (error) {
    console.error(error);
    return null;
  }
};

/**
 * Helper function to check if a string matches a known meeting link pattern
 * @param {String} value  string to parse and see if it matches a meeting link
 * @returns {Boolean}
 */
MeetingInfoUtil.isMeetingLink = function (value) {
  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);
  var hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(_constants.WEBEX_DOT_COM);
  var pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes('/' + _constants.MEET) || parsedUrl.pathname.includes('/' + _constants.MEET_M) || parsedUrl.pathname.includes('/' + _constants.JOIN));
  return hostNameBool && pathNameBool;
};

MeetingInfoUtil.convertLinkToSip = function (value) {
  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);
  if (!parsedUrl) {
    return null;
  }
  var user = void 0;
  if (parsedUrl.pathname) {
    var userIndex = parsedUrl.pathname.lastIndexOf('/');
    user = parsedUrl.pathname.substring(userIndex + 1);
  }
  if (!user) {
    return null;
  }
  var company = void 0;
  if (parsedUrl.hostname) {
    var companyIndex = parsedUrl.hostname.lastIndexOf('.' + _constants.WEBEX_DOT_COM);
    company = parsedUrl.hostname.substring(0, companyIndex).replace(_constants.WWW_DOT, '');
  }
  if (!company) {
    return null;
  }
  return user + '@' + company + '.' + _constants.WEBEX_DOT_COM;
};

MeetingInfoUtil.isSipUri = function (sipString) {
  // TODO: lets remove regex from this equation and user URI matchers and such
  // have not found a great sip uri parser library as of now
  var sipUri = _constants.DIALER_REGEX.SIP_ADDRESS.exec(sipString);
  return sipUri;
};

MeetingInfoUtil.isPhoneNumber = function (phoneNumber) {
  var isValidNumber = _constants.DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);
  return isValidNumber;
};

MeetingInfoUtil.generateOptions = function (from) {
  var destination = from.destination,
      type = from.type,
      conversationServiceUrl = from.conversationServiceUrl;

  if (type) {
    return {
      destination: destination,
      type: type
    };
  }
  var options = {};
  if (MeetingInfoUtil.isMeetingLink(destination)) {
    options.type = _constants.MEETING_LINK;
    options.destination = destination;
  } else if (MeetingInfoUtil.isSipUri(destination)) {
    options.type = _constants.SIP_URI;
    options.destination = destination;
  } else if (MeetingInfoUtil.isPhoneNumber(destination)) {
    options.type = _constants.SIP_URI;
    options.destination = destination;
  } else {
    options.type = _constants.CONVERSATION_URL;
    options.destination = conversationServiceUrl + '/' + _constants.CONVERSATIONS + '/' + destination;
  }
  return options;
};

/**
 * Helper function to build up a correct locus url depending on the value passed
 * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]
 * @param {Object} value ?? value.value
 * @returns {Object} returns an object with {resource, method}
 */
MeetingInfoUtil.getResourceUrl = function (type, value) {
  var resource = '/' + _constants.LOCI + '/' + _constants.MEETINGINFO;
  var method = _constants.GET;
  switch (type) {
    case _constants.SIP_URI:
    case _constants.PERSONAL_ROOM:
    case _constants.MEETING_ID:
      resource = '/' + _constants.LOCI + '/' + _constants.MEETINGINFO + '/' + value + '?' + _constants.TYPE + '=' + type + '&' + _constants.USE_URI_LOOKUP_FALSE;
      break;
    case _constants.CONVERSATION_URL:
      method = _constants.PUT;
      break;
    case _constants.LOCUS_ID:
      resource = '/' + _constants.LOCI + '/' + value + '/' + _constants.MEETINGINFO;
      method = _constants.PUT;
      break;
    case _constants.MEETING_LINK:
      resource = '$/' + _constants.LOCI + '/' + _constants.MEETINGINFO + '/' + (0, _btoa2.default)(value) + '?' + _constants.TYPE + '=' + _constants.MEETING_LINK + '&' + _constants.USE_URI_LOOKUP_FALSE;
      break;
    default:
  }
  return {
    resource: resource,
    method: method
  };
};

MeetingInfoUtil.getRequestParams = function (resourceOptions, type, value, api) {
  var requestParams = {
    method: resourceOptions.method,
    api: api,
    resource: resourceOptions.resource
  };
  if (resourceOptions.method === _constants.GET) {
    // for handling URL redirections
    requestParams.resource = requestParams.resource.concat('&' + _constants.ALTERNATE_REDIRECT_TRUE);
  } else if (type !== _constants.LOCUS_ID) {
    // locus id check is a PUT not sure why
    requestParams.body = {
      value: value,
      lookupType: type,
      alternateRedirect: true
    };
  }
  return requestParams;
};

MeetingInfoUtil.getMeetingInfoAPIFormat = function (options) {
  return {
    type: options.type,
    value: options.destination
  };
};

exports.default = MeetingInfoUtil;
//# sourceMappingURL=util.js.map
