/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */

import {ACTIVE, RECONNECTION} from '../constants';
import ReconnectionError from '../errors/reconnection';
import PeerConnectionManager from '../peer-connection-manager';

/**
 * @export
 * @class ReconnectionManager
*/
export default class ReconnectionManager {
  /**
   * @param {Meeting} meeting
   */
  constructor(meeting) {
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    this.configure(meeting);
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   */
  configure(meeting) {
    this.backOff = meeting.config.reconnection.retry.backOff.start;
  }

  /**
   * @returns {undefined}
   */
  reset() {
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
  }

  /**
   * @param {Meeting} meeting
   * @returns {Boolean}
   * @returns {ReconnectionError}
   */
  validate(meeting) {
    if (meeting.config.reconnection.enabled) {
      if (
        meeting.locusInfo
          && meeting.locusInfo.fullState
          && (
            meeting.locusInfo.fullState.state === ACTIVE
            && meeting.locusInfo.fullState.active
          )
      ) {
        if (meeting.spark.internal.mercury.connected) {
          if (
            this.status !== RECONNECTION.STATE.DEFAULT_STATUS
            || this.status !== RECONNECTION.STATE.COMPLETE
          ) {
            return true;
          }
          return new ReconnectionError(new Error('Multiple reconnections cannot occur concurrently'));
        }
        return new ReconnectionError(new Error('mercury is not connected, cannot reconnect'));
      }
      return new ReconnectionError(new Error('locus server for this call is not active, cannot reconnect'));
    }
    return new ReconnectionError(new Error('Reconnection is not enabled.'));
  }

  /**
   * @param {Meeting} meeting
   * @returns {Promise}
   */
  reconnect(meeting) {
    const validatedReconnect = this.validate(meeting);
    return validatedReconnect === true ? this.execute(meeting) : Promise.reject(validatedReconnect);
  }

  /**
   * @param {Meeting} meeting
   * @returns {Promise}
   */
  execute(meeting) {
    this.status = RECONNECTION.STATE.IN_PROGRESS;
    return this.media(meeting)
      .then((media) => {
        console.info(`Reconnection->Media reestablished at: ${new Date()}`);
        this.status = RECONNECTION.STATE.COMPLETE;
        return Promise.resolve(media);
      })
      .catch((err) => { // eslint-disable-line
        console.info(`Reconnection->Media reestablishment failed at: ${new Date()}`);
        if (this.tryCount > meeting.config.reconnection.retry.times) {
          this.status = RECONNECTION.STATE.FAILURE;
          return Promise.reject(new ReconnectionError(err));
        }
        // exponential backoff and retry logic
        setTimeout(() =>
          this.reconnect(meeting),
        this.backOff *= meeting.config.reconnection.retry.backOff.rate);
      });
  }

  /**
   * @param {Meeting} meeting
   * @returns {Promise} see #Meeting.addMedia
   */
  media(meeting) {
    this.tryCount += 1;
    console.info(`Reconnection->Re-establishing media at: ${new Date()}`);
    // create an offer
    return meeting.addMedia({
      mediaSettings: meeting.mediaProperties.mediaDirection
    }).then((media) => Promise.resolve(media))
      .catch((err) => {
        console.error('Could not re use peer connections for the media.', err);
        // TODO: test getting to this scenario
        ReconnectionManager.cleanup(meeting);
        return meeting.addMedia({
          mediaSettings: meeting.mediaProperties.mediaDirection,
          localStream: meeting.mediaProperties.localStream,
          localShare: meeting.mediaProperties.localShare
        });
      });
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   */
  static cleanup(meeting) {
    // close pcs, unset to null and reuse the streams with new pcs
    PeerConnectionManager.close(meeting.mediaProperties.mediaPeerConnection);
    PeerConnectionManager.close(meeting.mediaProperties.sharePeerConnection);
    meeting.mediaProperties.unsetPeerConnections();
  }
}
