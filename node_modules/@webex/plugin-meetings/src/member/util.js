import {
  USER,
  RESOURCE_ROOM,
  OBSERVE,
  NONE,
  WAIT,
  LEFT,
  JOINED,
  IDLE,
  IN_LOBBY,
  NOT_IN_MEETING,
  IN_MEETING,
  AUDIO_STATUS,
  VIDEO_STATUS,
  SEND_RECEIVE,
  RECEIVE_ONLY
} from '../constants';

const MemberUtil = {};

/**
 * @param {Object} participant the locus participant
 * @returns {Boolean}
 */
MemberUtil.isUser = (participant) => participant && participant.type === USER;

/**
 * @param {Object} participant the locus participant
 * @returns {Boolean}
 */
MemberUtil.isGuest = (participant) => participant && participant.guest;

/**
 * @param {Object} participant the locus participant
 * @returns {Boolean}
 */
MemberUtil.isDevice = (participant) => participant && participant.type === RESOURCE_ROOM;

/**
 * checks to see if the participant id is the same as the passed id
 * there are multiple ids that can be used
 * @param {Object} participant the locus participant
 * @param {String} id
 * @returns {Boolean}
 */
MemberUtil.isSame = (participant, id) => participant
  && (participant.id === id || participant.person && participant.person.id === id);

/**
 * checks to see if the participant id is the same as the passed id for associated devices
 * there are multiple ids that can be used
 * @param {Object} participant the locus participant
 * @param {String} id
 * @returns {Boolean}
 */
MemberUtil.isAssociatedSame = (participant, id) => participant
&& participant.associatedUsers
&& participant.associatedUsers.some((user) => (user.id === id || user.person && user.person.id === id));

/**
 * @param {Object} participant the locus participant
 * @param {Boolean} isGuest
 * @param {String} status
 * @returns {Boolean}
 */
MemberUtil.isNotAdmitted = (participant, isGuest, status) => participant
  && participant.guest && participant.devices && participant.devices[0]
  && participant.devices[0].intent && participant.devices[0].intent.type === WAIT
  && isGuest && status === IN_LOBBY;

/**
 * @param {Object} participant the locus participant
 * @returns {Boolean}
 */
MemberUtil.isAudioMuted = (participant) => {
  if (!participant) {
    throw new Error('Audio could not be processed, participant is undefined.');
  }
  const mutedStatus = MemberUtil.isMuted(participant.status, AUDIO_STATUS);
  if (participant.controls && participant.controls.audio) {
    if (participant.controls.audio.muted) {
      return true;
    }
    if (mutedStatus) {
      return true;
    }
  }
  return false;
};

/**
 * @param {Object} participant the locus participant
 * @returns {Boolean}
 */
MemberUtil.isVideoMuted = (participant) => {
  if (!participant) {
    throw new Error('Video could not be processed, participant is undefined.');
  }
  return MemberUtil.isMuted(participant.status, VIDEO_STATUS);
};

/**
 * utility method for audio/video muted status
 * @param {String} status
 * @param {String} accessor
 * @returns {Boolean}
 */
MemberUtil.isMuted = (status, accessor) => {
  if (status) {
    if (status[accessor] === RECEIVE_ONLY) {
      return true;
    }
    if (status[accessor] === SEND_RECEIVE) {
      return false;
    }
  }
  return null;
};

/**
 * @param {Object} participant the locus participant
 * @returns {Boolean}
 */
MemberUtil.isRecording = (participant) => {
  if (!participant) {
    throw new Error('Recording could not be processed, participant is undefined.');
  }
  if (participant.controls && participant.controls.localRecord) {
    return participant.controls.localRecord.recording;
  }
  return false;
};

/**
 * @param {Object} participant the locus participant
 * @returns {String}
 */
MemberUtil.extractStatus = (participant) => {
  if (!(participant && participant.devices && participant.devices.length)) {
    return NOT_IN_MEETING;
  }
  const device = participant && participant.devices ? participant.devices[0] : null;
  if (device) {
    if (device.state === JOINED && (!device.intent || device.intent.type === NONE)) {
      return IN_MEETING;
    }
    if (device.state === IDLE && device.intent && (device.intent.type === WAIT || device.intent.type === OBSERVE)) {
      return IN_LOBBY;
    }
    if (device.state === LEFT || (device.state === IDLE && (!device.intent || device.intent.type === NONE))) {
      return NOT_IN_MEETING;
    }
  }
  return NOT_IN_MEETING;
};

/**
 * @param {Object} participant the locus participant
 * @returns {String}
 */
MemberUtil.extractId = (participant) => {
  if (participant) {
    return participant.id;
  }
  return null;
};

/**
 * @param {Object} participant the locus participant
 * @returns {String}
 */
MemberUtil.extractName = (participant) => {
  if (participant && participant.person) {
    return participant.person.name;
  }
  return null;
};

export default MemberUtil;
