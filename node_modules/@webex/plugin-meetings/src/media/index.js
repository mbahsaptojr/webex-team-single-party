/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
/* globals navigator */

/* eslint-disable no-logger */
import {AUDIO_INPUT, VIDEO_INPUT} from '../constants';
/**
 *
 * @export
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 */
const Media = {};

Media.setLocalTracks = (audio, video, stream) => {
  Media.setLocalAudioTracks(audio, stream);
  Media.setLocalVideoTracks(video, stream);
};

Media.setLocalAudioTracks = (audio, stream) => {
  if (stream) {
    if (stream.getAudioTracks) {
      const [audioTrack] = stream.getAudioTracks();
      if (audioTrack) {
        audioTrack.enabled = !audio.mute;
        return true;
      }
    }
  }
  return false;
};

Media.setLocalVideoTracks = (video, stream) => {
  if (stream) {
    if (stream.getVideoTracks) {
      const [videoTrack] = stream.getVideoTracks();
      if (videoTrack) {
        videoTrack.enabled = !video.mute;
        return true;
      }
    }
  }
  return false;
};

Media.generateLocalMedias = (mediaId, audio, video) => {
  if (mediaId) {
    return [
      {
        localSdp: JSON.stringify({
          audioMuted: audio.mute,
          videoMuted: video.mute
        }),
        mediaId
      }
    ];
  }
  return [];
};

Media.getLocalMedia = (options) => {
  const {sendAudio, sendVideo, sendShare} = options;
  // we return undefined here as the second param until screen share is implemented

  if (sendAudio || sendVideo) {
    return Media.getMedia(sendAudio, sendVideo);
  }

  if (sendShare) {
    return Media.getDisplayMedia(
      {
        sendAudio: false,
        sendShare: true
      }
    );
  }

  return Promise.resolve(undefined);
};
/**
 * creates peerconnection and attaches streams
 * @param {object} mediaDirection mediaDirection
 * @param {Object} pcManager peerConnectionManager instance
 * @param {Object} audioVideo audioVideo streams
 * @param {Object} localShare sendScreen: {Boolean} sendShare constraints
 * @param {Object} mappedPCs {mediaPeerConnection, sharePeerConnection}
 * @returns {Array} [mediaPeerConnection, sharePeerConnection ]
 */
Media.attachMedia = (mediaDirection, pcManager, audioVideo, localShare, mappedPCs = {}) => {
  const promises = [];
  // Create a peer
  if (mediaDirection.receiveVideo || mediaDirection.receiveAudio
  || audioVideo) {
    promises.push(
      pcManager.createOffer({
        receiveAudio: mediaDirection.receiveAudio,
        receiveVideo: mediaDirection.receiveVideo,
        // After you get the localStream
        streams: audioVideo,
        peerConnection: mappedPCs.mediaPeerConnection
      })
    );
  }
  else {
    promises.push(undefined);
  }

  if (mediaDirection.receiveShare || localShare) {
    promises.push(
      pcManager.createOffer({
        // its for screen sharing but can change in future when user wants just share with audio
        receiveAudio: false,
        receiveVideo: mediaDirection.receiveShare,
        // After you get the localStream
        streams: localShare,
        peerConnection: mappedPCs.sharePeerConnection
      })
    );
  }
  return Promise.all(promises);
};
/**
 * generates share streams (chrome)
 * @param {object} options parameter
 * @param {Object} options.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} options.sendScreen sendScreen: {Boolean} sendShare constraints
 * @returns {Object} {streams}
 */
Media.getDisplayMedia = (options) =>
  navigator.mediaDevices.getDisplayMedia({audio: options.sendAudio, video: options.sendScreen});

/**
 * generates audio and video using constraints (often called after getSupportedDevices)
 * @param {Object} audio audio: {Boolean} gum constraints
 * @param {Object} video video: {Boolean} gum constraints
 * @returns {Object} {streams}
 */
Media.getMedia = (audio, video) => {
  const mediaConfig = {
    audio,
    video
  };

  return new Promise((resolve, reject) => {
    navigator.mediaDevices
      .getUserMedia(mediaConfig)
      .then((stream) => {
        resolve(stream);
      })
      .catch((err) => {
        reject(
          new Error({
            name: err.name,
            localMediaFailed: true,
            cameraFailed: err === mediaConfig.permissionDenied
          })
        );
      });
  });
};

/**
 * Checks if the machine has at least one audio or video device (Dont use this for screen share)
 * @param {object} options optional parameter
 * {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 * }
 * @returns {Object} {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 *}
 */
Media.getSupportedDevice = ({sendAudio, sendVideo}) =>
  Promise.resolve().then(() => {
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return {
        sendAudio: true,
        sendVideo: true
      };
    }

    return navigator.mediaDevices.enumerateDevices().then((devices) => {
      const supported = {
        audio: devices.filter((device) => device.kind === AUDIO_INPUT).length > 0,
        video: devices.filter((device) => device.kind === VIDEO_INPUT).length > 0
      };
      return {
        sendAudio: (supported.audio && sendAudio) || true,
        sendVideo: (supported.video && sendVideo) || true
      };
    });
  });

/**
 *
 * Toggle a specific stream
 * @returns {null}
 */
Media.toggleStream = () => {};

/**
 *
 * Stop input stream
 * @param {Stream} stream A media stream
 * @returns {null}
 * @memberof Media
 */
Media.stopStream = (stream) => {
  if (!stream) {
    return Promise.resolve();
  }
  /*
   * To release local media
   * 1) Chrome requires all tracks to be stopped (stream.stop got deprecated)
   * 2) Firefox requires the stream to be stopped
   */
  return Promise.resolve().then(() => {
    if (stream.getTracks) {
      stream.getTracks().forEach((track) => {
        track.stop();
      });
    }
    else if (stream.stop) {
      stream.stop();
    }
  });
};

/**
 * generates streams for audio video and share
 * @param {object} mediaSetting parameter
 * @param {Object} mediaSetting.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} mediaSetting.sendVideo sendVideo: {Boolean} sendVideo constraints
 * @param {Object} mediaSetting.sendScreen sendScreen: {Boolean} sendShare constraints
 * @returns {Array} [localStream, shareStream]
 */
Media.getUserMedia = (mediaSetting) => Media.getLocalMedia({
  sendAudio: mediaSetting.sendAudio,
  sendVideo: mediaSetting.sendVideo
})
  .then((localStream) => Media.getLocalMedia({
    sendShare: mediaSetting.sendShare
  }).then((shareStream) => [localStream, shareStream]));


export default Media;
