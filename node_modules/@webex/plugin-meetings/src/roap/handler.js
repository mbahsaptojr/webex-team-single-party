/* eslint-disable no-console,no-param-reassign */
import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import MeetingCollection from '../meetings/collection';
import Events from '../events';
import {ROAP, EVENTS, OFFER} from '../constants';
import RoapUtil from '../roap/util';
import RoapCollection from '../roap/collection';

const checkForAndHandleErrors = (action, meeting, correlationId) => {
  if (action && action.type) {
    if (action.msg && action.msg.messageType && action.msg.errorType) {
      if (RoapUtil.findError(action.msg.messageType, action.msg.errorType, action.type)) {
        RoapUtil.handleError(meeting.mediaProperties.mediaPeerConnection)
          .then((res) => {
            if (res) {
              RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);
            }
          })
          .catch((err) => {
            this.logger.info('Cannot reset the peer connection', err);
          });
        return true;
      }
    }
    if (!RoapUtil.ensureMeeting(meeting, action.type)) {
      return true;
    }
  }
  return false;
};

const handleSessionStep = (roap, session) => {
  const {seq: sequenceId, messageType} = roap.msg;
  if (session.OFFER && messageType === OFFER) {
    session.GLARE_OFFER = roap.msg;
    session.GLARE_OFFER.remote = !!roap.remote;
    console.info(`Its a GLARE condition seq:${sequenceId} new mercury event`);
  }
  else {
    console.info(
      `Save OFFER/ANSWER seq:${sequenceId} new mercury event ${messageType}local state: ${JSON.stringify(
        session.state.state,
        null,
        2
      )}`
    );
    session[messageType] = roap.msg;
    session[messageType].remote = !!roap.remote;
  }
};
/**
 * @class RoapHandler
 */
export default class RoapHandler extends StatelessSparkPlugin {
  /**
   *
   * @param {Object} session
   * @param {Meeting} meeting
   * @param {Object} action
   * @returns {null}
   */
  perform(session, meeting, action) {
    switch (session.state.state) {
      // case ROAP.ROAP_STATE.INIT:
      // case ROAP.ROAP_STATE.WAIT_RX_OFFER:
      // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
      // case ROAP.ROAP_STATE.WAIT_RX_OK:
      case ROAP.ROAP_STATE.WAIT_TX_ANSWER:
        // eslint-disable-next-line no-warning-comments
        // TODO: sometime the you get an answer while you are creating an offer so SKIP
        // Server will send the mercury event comes back
        if (RoapUtil.shouldHandleMedia(meeting)) {
          RoapUtil.updatePeerConnection(meeting, session)
            .then((answerSdps) => {
              Events.emit(EVENTS.ROAP_ANSWER, {
                locusId: meeting.locusId,
                locusSelfId: meeting.locusInfo.self.id,
                mediaId: meeting.mediaId,
                sdps: answerSdps,
                seq: session.OFFER.seq,
                correlationId: meeting.correlationId,
                audioMuted: meeting.isAudioMuted(),
                videoMuted: meeting.isVideoMuted()
              });
            })
            .catch((err) => {
              this.logger.error(err);
            });
        }
        break;
      case ROAP.ROAP_STATE.WAIT_TX_OK:
        RoapUtil.setRemoteDescription(meeting, session).then((res) => {
          Events.emit(EVENTS.ROAP_OK, res);
        });
        break;
      // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:
      case ROAP.ROAP_STATE.ERROR:
        this.logger.error('Call-RoapHandler#ERROR state=error', session);
        break;
      case ROAP.ROAP_STATE.GLARE:
        session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
        session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
        this.logger.error('Resolve the GLARE condition');
        if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
          // 2
          this.logger.error('local offer wins');
        }
        else {
          this.logger.error('remote offer wins', session);
        }
        session.state.step(ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, action);
        this.perform(session, meeting);
        break;
      default:
        break;
    }
  }

  /**
   *
   * @param {String} signal
   * @param {Object} session
   * @param {Object} action
   * @param {Meeting} meeting
   * @param {String} prefix
   * @returns {null}
   */
  execute(signal, session, action, meeting, prefix) {
    if (session && session.state) {
      handleSessionStep(action, session);
      signal = ROAP.ROAP_SIGNAL[`${prefix}${action.msg.messageType}`];
      session.state.step(signal, meeting, action);
      this.perform(session, meeting, action);
    }
  }

  /**
   *
   * @param {Object} session
   * @param {Object} action
   * @param {Meeting} meeting
   * @param {String} correlationId
   * @returns {Boolean}
   */
  handleAction(session, action, meeting, correlationId) {
    let signal;
    switch (action.type) {
      case ROAP.RECEIVE_ROAP_MSG:
        action.remote = true;
        this.execute(signal, session, action, meeting, ROAP.RX_);
        break;
      case ROAP.SEND_ROAP_MSG:
        action.local = true;
        this.execute(signal, session, action, meeting, ROAP.TX_);
        break;
      case ROAP.SEND_ROAP_MSG_SUCCESS:
        // This means we got and answer and waiting for 200 ok for /participants
        if (RoapCollection.getSessionSequence(correlationId, action.seq).ANSWER) {
          signal = ROAP.ROAP_SIGNAL.RX_ANSWER;
          // NOTE: When server send back an answer via mercury the
          // remote SDP is already saved sent and ok message is sent back
          // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
          // RoapHandler.transition(signal, session, meeting);
        }
        break;
      case 'RECEIVE_CALL_LEAVE':
        RoapCollection.deleteSession(correlationId);
        console.info('Call-this#RECEIVE_CALL_LEAVE: cleaning up the RoapHandler', correlationId);
        break;
      case ROAP.RESET_ROAP_STATE:
        RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);
        console.info('Call-RoapHandler#RESET_ROAP_STATE: resetting the RoapHandler state', action.msg.seq);
        break;
      default:
        return true;
    }
    return true;
  }

  /**
   *
   * @param {Object} action
   * @returns {Boolean}
   */
  submit(action) {
    const {correlationId} = action;
    const session = RoapCollection.getSessionSequence(correlationId, action.seq || action.msg.seq);
    const meeting = MeetingCollection.get(correlationId);
    if (checkForAndHandleErrors(action, meeting, correlationId)) {
      return true;
    }
    return this.handleAction(session, action, meeting, correlationId);
  }
}
