import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {DEFAULT_EVENT_VIDEO_SEND_KEYS, DEFAULT_EVENT_AUDIO_SEND_KEYS, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_TYPES, EVENT_TRIGGERS, EVENT_STATS_MAP, MEETINGS, AUDIO, VIDEO} from '../constants';

/**
 * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against
 * @param {String} type - local or remote
 * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX
 * @param {String} stat - the accessor to get the actual stat
 * @param {String} kind - audio or video
 * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never
 */
const operateEvent = (operate, type, keys, stat, kind) => {
  const foundMatch = {};
  foundMatch.found = keys.some((key) => {
    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {
      foundMatch.match = {
        type,
        key,
        data: operate[key],
        stat,
        kind
      };
      return true;
    }
    return false;
  });
  return foundMatch;
};

export default class StatsEvents extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   * constructs an instance
   * @param {Object} attrs
   * @param {Object} options
   */
  constructor(attrs, options) {
    super({}, options);
    this.sentFirstVideoBytes = undefined;
    this.receivedFirstVideoBytes = undefined;
    this.sentFirstAudioBytes = undefined;
    this.receivedFirstAudioBytes = undefined;
  }

  /**
   * handles the first audio bytes received
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never
   */
  receiveEventAudio(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();
      if (operate && !this.receivedFirstAudioBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO);
        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.receivedFirstAudioBytes = somethingMatched.match;
          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.receivedFirstAudioBytes);
        }
      }
    }
    return this.receivedFirstVideoBytes;
  }

  /**
   * handles the first video bytes received
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never
   */
  receiveEventVideo(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();
      if (operate && !this.receivedFirstVideoBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO);
        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.receivedFirstVideoBytes = somethingMatched.match;
          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.receivedFirstVideoBytes);
        }
      }
    }
    return this.receivedFirstVideoBytes;
  }

  /**
   * handles the first video bytes sent
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never
   */
  sendEventVideo(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();
      if (operate && !this.sentFirstVideoBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_VIDEO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, VIDEO);
        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.sentFirstVideoBytes = somethingMatched.match;
          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.sentFirstVideoBytes);
        }
      }
    }
    return this.sentFirstVideoBytes;
  }

  /**
   * handles the first audio bytes sent
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first sentFirstAudioBytes were, in the past or if it happened now, or undefined if never
   */
  sendEventAudio(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();
      if (operate && !this.sentFirstAudioBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_AUDIO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, AUDIO);
        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.sentFirstAudioBytes = somethingMatched.match;
          this.trigger(EVENT_TRIGGERS.STATS_UPDATE, this.sentFirstAudioBytes);
        }
      }
    }
    return this.sentFirstVideoBytes;
  }

  /**
   * handles all the types of events that need to be sent when they happen from getStats API
   * @param {WebRTCData} data
   * @returns {Object}
   */
  event(data) {
    return {
      sentFirstVideoBytes: this.sendEventVideo(data),
      receivedFirstVideoBytes: this.receiveEventVideo(data),
      sentFirstAudioBytes: this.sendEventAudio(data),
      receivedFirstAudioBytes: this.receiveEventAudio(data)
    };
  }
}
